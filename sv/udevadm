#!/sbin/rs
#
# $Header: /etc/sv/udevadm                                 Exp $
# $License: 2-clause/new/simplified BSD                    Exp $
#

SVC_AFTER="kmod"
SVC_BEFORE="checkfs device-mapper dmcrypt lvm"
SVC_NEED="udev"
SVC_COMMANDS="reload"
udevadm="$(command -v udevadm 2>${NULL})"

start_pre()
{
	if ! [ -n "${udevadm}" ]; then
		error "No udevadm command found"
		return 1
	fi
}
start_exec()
{
	${udevadm} control --start-exec-queue --timeout=${UDEV_START_TIMEOUT:-60}
}

start()
{
	if yesno "${DEV_ROOT_SYMLINK:-1}"; then
		local RULESDIR=/run/udev/rules.d
		mkdir -p ${RULESDIR}
		eval $(udevadm info --export --export-prefix=ROOT_ --device-id-of-file=/)
		if [ -n "${ROOT_MAJOR}" -a -n "${ROOT_MINOR}" -a "${ROOT_MAJOR}" != 0 ]; then
			echo 'ACTION=="add|change", SUBSYSTEM=="block", ENV{MAJOR}=="'${ROOT_MAJOR}'", ENV{MINOR}=="'${ROOT_MINOR}'", SYMLINK+="root"' >${RULESDIR}/61-dev-root-link.rules
		fi
	fi

	#
	# XXX: this necessary to get a function udev early (see BUGS.md)
	#
	local count=1
	begin "Starting to process events"
	while ! start_exec; do
		count=$((${count}+1))
		[ "${count}" = 50 ] && break
		sleep 0.2
	done
	end "${?}"

	begin "Waiting uevents to be processed"
	${udevadm} settle --timeout=${UDEV_SETTLE_TIMEOUT:-60}
	end "${?}"

	begin "Populating /dev with uevents"
	${udevadm} trigger --type=subsystems --action=add
	${udevadm} trigger --type=devices --action=add
	end "${?}"

	return 0
}

stop()
{
	${udevadm} control --exit
}

reload()
{
	${udevadm} control --reload
}

#
# vim:fenc=utf-8:ft=sv:ci:pi:sts=0:sw=4:ts=4:
#
