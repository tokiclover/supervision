#
# $Header:  /etc/sv/.opt/runscript-functions             Exp $
# $Author: (c) 2015 -tclover <tokiclover@gmail.com>      Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.0 2015/04/20 21:09:26                      Exp $
#

env_rs()
{
	[ -n "${*}" ] && set_env "RS_OPTIONS" "${@}"
}

rs_status()
{
	local msg
	rs_state -s && msg=started || msg=stopped
	echo -n ${msg}
}

rs_add()
{
	rs_state -e && ln -fns ${RS_SVCDIR}/${SVC_NAME} ${RS_RUNDIR}
}

rs_del()
{
	rm -f ${RS_RUNDIR}/${SVC_NAME}
}

rs_zap()
{
	rm -f ${SV_TMPDIR}/${SVC_NAME}_OPTIONS ${SV_TMPDIR}/*/${SVC_NAME}
}

rs_cmd()
{
	local ARGS CMD END FAIL cmd val
	END='{ end 0; return; }' cmd="${1}"
	FAIL='[ ${val} = 0 ] || { val=2; rs_zap; break; }'

	case "${cmd}" in
		(start|stop)
		case "${2}" in
			(stage) ARGS="${1} ${3}" CMD=svc_stage cmd=stage;;
			(*) CMD="${cmd}_pre ${cmd} ${cmd}_post";;
		esac;;
		(restart) command -v ${cmd} >${NULL} 2>&1 ||
			CMD="stop_pre stop stop_post
			   start_pre start start_post";;
		(add|del|status|zap) CMD=rs_${cmd};;
		(desc)  ARGS="${2}" CMD=svc_desc  ;;
		(*) ARGS='"${@}"' CMD=svc_commands;;
	esac

	begin "service ${cmd}: "
	case "${cmd}" in
		(start)
		rs_wait   || { end 1 "busy"; return 4; }
		svc_state -s && eval ${END}
		svc_mark  -d
		svc_depend;;
		(stop)
		svc_state -s || eval ${END};;
	esac

	for cmd in ${CMD}; do
		command -v ${cmd} >${NULL} 2>&1 || continue
		eval ${cmd} ${ARGS}
		case ${?} in
			(0)
			case ${cmd} in
				(start) svc_mark -s -u;;
				(stop)  svc_mark -S -u;;
			esac;;
			(*)
			case ${cmd} in
				(start_pre) eval ${FAIL};;
				(stop_post) eval ${FAIL};;
			esac
			val=$((${val}+1));;
		esac
	done
	end ${val-${?}}
	return ${val}
}

rs_state()
{
	local arg ret
	for arg in ${@--r}; do
		case "${arg}" in
			(-e|--exist) [ -e ${RS_SVCDIR}/${SVC_NAME} ];;
			(-r|--runn*) [ -e ${RS_RUNDIR}/${SVC_NAME} ];;
			(*) svc_state "${arg}";;
		esac
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

rs_stage()
{
	local cmd opt svc lvl
	local CMD DEP SRV dep df i line srv

	while true; do
	case "${1}" in
		(*-[0123]) lvl=${1} ;;
		(-f|--fo*) opt='&'  ;;
		(-S|*stop) cmd=stop ;;
		(-s|*sta*) cmd=start;;
		(-r|--runs*) SRV=rs srv=${1};;
		(-v|--supe*) SRV=sv srv=${1};;
		(*) break;;
	esac
	shift
	done

	[ -n "${lvl}" ] || return 1
:	${cmd:=start}
:	${SRV:=rs}
	export RS_STAGE=stage-${lvl#*-}
	case ${cmd} in
		(start) ${SV_SVCDIR}/.opt/dep ${lvl} ${srv:-r}
		        DEP='need use after before' ORD='2 1 0';;
		(stop)  DEP='before after use need' ORD='0 1 2';;
	esac
	case ${SRV} in
		(rs) CMD='${RS_SVCDIR}/${svc}'     ;;
		(sv) CMD='${SV_SERVICE}/${svc}/run';;
	esac

	for dep in ${DEP}; do
		local ${dep}_0 ${dep}_1 ${dep}_2
		df=${SV_TMPDIR}/deps/${RS_STAGE}/${SRV}_${dep}
		[ -f ${df} ] && source ${df} || continue

		for i in ${ORD}; do
			case ${i} in
				(0)
				case ${dep} in
					(${DEP##* });;
					(*) continue;;
				esac;;
			esac
			for svc in $(eval echo \$${dep}_${i}); do
			eval ${CMD} ${cmd} ${opt}
		done
		done
	done
}

rs_wait()
{
	local VAL
	while [ -e ${SV_TMPDIR}/down/${1-${SVC_NAME}} ]; do
		VAL=$((${VAL}+1))
		[ ${VAL} -eq ${2-65536} ] && return 1
	done
	return 0
}

svc_stage()
{
	case "${*}" in
		(*-0*) tmp_service;;
	esac
	rs_stage "${@}" -f
	rs_stage "${@}"
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
