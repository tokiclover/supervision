#
# $Header:  /etc/sv/.opt/supervision-functions           Exp $
# $Author: (c) 2015 -tclover <tokiclover@gmail.com>      Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 2.8 2015/04/14 21:09:26                      Exp $
#

#
# @FUNCTION: Create (supervision) service
# @ARG: [SVC_NAME]
#
svc_add()
{
	local cmd chk dwn log sym svc name dir
	while [ $# -ge 1 ]; do
		case "${1}" in
			(-c|--check)   chk=0; shift;;
			(-d|--down)    dwn=0; shift;;
			(-l|--log)     log=0; shift;;
			(-s|--service) svc=0; shift;;
			(*) break;;
		esac
	done
:	${name:=${1:-${SVC_NAME}}}
:	${dir=${SV_SVCDIR}/${name}}
	if [ -n "${chk}" ]; then
		if ! type -p ${SVC_CMD:-${name}} >${NULL} 2>&1; then
			error "Command not found."
			return 1
		fi
	fi
	[ -e "${SV_RUNDIR}/${name}"  ] && return 0
	[ -n "${log}" ] && mkdir -p "${dir}"/log || mkdir -p "${dir}"

	for cmd in finish run ${log:+log/run log/finish}; do
		[ -x "${dir}/${cmd}" ] && continue
		[ "${cmd#log/}" != "${cmd}" ] && log=0 || log=
		ln -s ${log:+../}../.opt/cmd "${dir}/${cmd}"
	done
	[ -f ${dir}/OPTIONS ] || sed -e "s|@svc@|${name}|" \
		${SV_SVCDIR}/.opt/OPTIONS.in >${dir}/OPTIONS
	[ -n "${dwn}" ] && svc_down
	[ -n "${svc}" ] || return 0
	case ${SV_RUNDIR} in
		(${SV_SERVICE}) ;;
		(*) cp -LRpu ${dir} ${SV_RUNDIR};;
	esac
	[ -e ${SV_SERVICE}/${name} ] || ln -ns ${dir} ${SV_SERVICE}
	[ -z "${SCANCMD}" ] || eval ${SCANCMD}
}

svc_down()
{
	case "${1}" in
		(-r|--remove) rm -f "${SV_RUNDIR}/${SVC_NAME}"/down;;
		(-d|--down|*) touch "${SV_RUNDIR}/${SVC_NAME}"/down;;
	esac
}

svc_start()
{
	svc_add --service || return
	local val
	eval ${SVCCMD} ${SIGWTUP:-${SIGSTRT}} "${SV_RUNDIR}/${SVC_NAME}"
	case ${?} in
		(0) svc_mark --up -s ;;
		(*) val=1;;
	esac
	svc_down --remove
	return ${val}
}

svc_stop()
{
	local SIG val
	for SIG in STOP TERM; do
		eval ${SVCCMD} \${SIG${SIG}} "${SV_RUNDIR}/${SVC_NAME}"
	done
	val=${?}
	[ ${val} -eq 0 ] && svc_mark -S
	return ${val}
}

svc_status()
{
	eval ${CHKCMD} "${SV_RUNDIR}/${SVC_NAME}"
}

svc_reload()
{
	if [ -n "${SIGRLD}" ]; then
		eval ${SVCCMD} ${SIGRLD} "${SV_RUNDIR}/${SVC_NAME}"
	else
		eval ${SVCCMD} ${SIGHUP:-${SIGEXIT}} "${SV_RUNDIR}/${SVC_NAME}"
		svc_start
	fi
}

svc_mark()
{
	local arg ret
	for arg in ${@:--s}; do
		case "${arg}" in
			(-d|--down*)  touch "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-u|--up*)    rm -f "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-f|--failed) touch "${SV_TMPDIR}/fail/${SVC_NAME}";;
			(-s|--start*) touch "${SV_TMPDIR}/star/${SVC_NAME}";;
			(-S|--stoped) rm -f "${SV_TMPDIR}/star/${SVC_NAME}";;
		esac
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

svc_state()
{
	local S arg ret
	case "${SRV}" in
		(sv) S=SV;;
		(rs) S=RS;;
	esac
	for arg in ${@:--r}; do
		case "${arg}" in
			(-R|--runs*) S=RS;;
			(-V|--supe*) S=SV;;
			(-e|--exist) eval [ -e "\${${S}_SVCDIR}/${SVC_NAME}" ];;
			(-r|--runn*) eval [ -e "\${${S}_RUNDIR}/${SVC_NAME}" ];;
			(-f|--fail*) [ -e "${SV_TMPDIR}/fail/${SVC_NAME}" ];;
			(-s|--star*) [ -e "${SV_TMPDIR}/star/${SVC_NAME}" ];;
			(-d|--down*) [ -e "${SV_TMPDIR}/down/${SVC_NAME}" ];;
		esac
		ret=$((${ret} + ${?}))
	done
	return ${ret}
}

#
# @FUNCTION: Pre-Run handler
#
svc_pre()
{
	local REMOVE_SVC file
	REMOVE_SVC='{ svc_remove; die "Failed to setup ${SVC_NAME}"; };'

	if [ -x ./RUN ]; then
		SVC_CMD=./RUN
	else
		SVC_CMD=$(type -p ${SVC_CMD:-${SVC_NAME}} 2>${NULL})
	fi
	if ! [ -n "${SVC_CMD}" -a -x "${SVC_CMD}" ]; then
		error "Command not found."
		eval ${REMOVE_SVC}
	fi
	for file in ${SVC_CONFIGFILE} ${SVC_REQ_FILES}; do
		if [ ! -f "${file}" ]; then
			error "${file} required file not found"
			eval ${REMOVE_SVC}
		fi
	done
	if command -v pre >${NULL} 2>&1; then
		pre || eval ${REMOVE_SVC}
	fi
}
svc_remove()
{
	begin "Removing ${SVC_NAME} service"
	rm -fr "${SV_RUNDIR}/${SVC_NAME}"
	end ${?}
	rm -f "${SV_TMPDIR}/${SVC_NAME}_OPTIONS"
	svc_mark --failed
}

#
# @FUNCTION: Pre-Finish handler
#
svc_post()
{
	if yesno "${SV_CGROUP}"; then
		cgroup_remove_service
	fi
	if command -v post >${NULL} 2>&1; then
		post || error "Failed to exec post()"
	fi
	#
	# Handle run return values
	#
	case "${cmd_args}" in
		(0*)
			;;
		(*)
			SVC_TRY=$((${SVC_TRY} + 1))
			env_svc SVC_TRY
			if [ ${SVC_TRY:-0} -ge ${SV_TRY:-3} ]; then
				error "Maximum number of starting attempts reached."
				svc_remove
			fi
			;;
	esac
}

#
# @FUNCTION: Handle service deps
#
svc_depend()
{
	local dep
	yesno ${SVC_NODEPS:-NO} && return

	for dep in ${2-use:USE need:NEED before:BEFORE after:AFTER}; do
		eval [ -n \"\${SVC_${dep#*:}}\" ] &&
		command -v svc_${dep%:*} >${NULL} 2>&1 || continue
		eval svc_${dep%:*} ${1}
		eval RET_${dep#*:}=${?}
	done

	DEP_RET=${RET_NEED:-0}
	yesno ${RS_STRICT_DEP:-NO} && DEP_RET=$((${DEP_RET}+${RET_AFTER}+${RET_USE}))
	case ${DEP_RET} in
		(0) echo $$ >${SVC_PID};;
		(*) return ${DEP_RET}  ;;
	esac
}

svc_after()
{
	local svc SVC
	SVC=${SVC_NAME}
	for svc in ${2-${SVC_AFTER}}; do
		SVC_NAME="${svc}"
		svc_state -s && continue
		svc_state -r && svc_cmd ${1-start}
	done
	SVC_NAME=${SVC}
}

svc_need()
{
	local val
	if ! svc_use ${1-start} "${2-${SVC_NEED}}"; then
		val=${?}
		error "Failed to set up service dependencies."
		return ${val}
	fi
}
svc_use()
{
	local ret svc SVC
	SVC=${SVC_NAME}
	for svc in ${2-${SVC_USE}}; do
		SVC_NAME="${svc}"
		svc_state -f && ret=$((${ret}+1)) || svc_cmd ${1-start}
		ret=$((${ret}+${?}))
	done
	SVC_NAME=${SVC}
	return ${ret}
}

#
# @FUNCTION: Set persistent env between run/finish
#
set_env()
{
	local OPT env; OPT="${1}"
	shift
	for env; do
		eval echo "${env}=\"'\$${env}'\""
		shift
	done >>"${SV_TMPDIR}/${OPT}"
}
env_svc()
{
	[ -n "${@}" ] && set_env "${SVC_NAME}_OPTIONS" "${@}"
}
env_sv()
{
	[ -n "${@}" ] && set_env "SV_OPTIONS" "${@}"
}

#
# @FUNCTION: Set up CGroup
#
svc_cgroup()
{
	if [ -z "${SV_CGROUP}" ]; then
		cgroup_start_sys
		case ${?} in
			(0) SV_CGROUP=Yes;;
			(*) SV_CGROUP=No ;;
		esac
		env_sv SV_CGROUP
	fi
	if yesno "${SV_CGROUP}"; then
		cgroup_add_service
	fi
}

svc_desc()
{
	local desc
	eval desc=\"\${description${1:+_$1}}\"
	if [ -n "${desc}" ]; then
		name=description info "${desc}"
	else
		warn "No description found"
	fi
}

#
# @FUNCTION: Handle extra service commands
#
svc_commands()
{
	if [ -z "${SVC_COMMANDS}" ]; then
		error "No extra commands found."
		return 1
	elif [ "${SVC_COMMANDS/${@}}" = "${SVC_COMMANDS}" ]; then
		error "${@} command not found."
		return 2
	fi
	local cmd; cmd=${1}
	if command -v ${cmd} >${NULL} 2>&1; then
		shift
		begin "processing ${cmd} ..."
		eval ${cmd} "${@}"
		end ${?}
	else
		error "${cmd} command not defined."
		return 3
	fi
}

svc_cmd()
{
	local arg cmd opt pfx; pfx=svc_
	for arg; do
		case "${1}" in
			(add|remove|desc|reload|zap) cmd=${1} ;;
			(start|stop|status)        cmd=${1}   ;;
			(cgroup_remove_service) cmd=${1} pfx= ;;
			(-[cdls]*|--[cdls]*) opt="${opt} ${1}";;
			(-*) error "Invalid option"; return 3 ;;
			(*) [ -z "${cmd}" ] && cmd=commands; opt='"${@}"'
				break;;
		esac
		shift
	done

	case "${cmd}" in
		(*remove*|reload|stop|status)
			svc_state -r || (svc_state -R -r && pfx='rs_cmd ') ||
			{ error "Inactive service" ; return 1; };;
		(desc|start)
			svc_state -e || (svc_state -R -e && pfx='rs_cmd ') ||
			{ error "Inexistent service"; return 2; };;
	esac
	begin "service ${cmd}: "
	eval ${pfx}${cmd} ${opt}
	end "${?}"
}

svc_env()
{
	local dir file
	for dir in ../.env env; do
		[ -d "${SV_RUNDIR}/${dir}" ] && ENV_CMD="${ENV_CMD} envdir ${SV_RUNDIR}/${dir}"
	done
	for file in SVC_USER SVC_GROUP; do
		[ -f "${SV_RUNDIR}/env/${file}" ] && eval ${file}=$(cat "${SV_RUNDIR}/env/${file}")
	done
	ENV_OPTS="${ENV_OPTS} ${SVC_USER:+envuidgid ${SVC_USER}${SVC_GROUP:+:}${SVC_GROUP}}"
}

svc_run()
{
	if [ ${#} -ge 1 ]; then
		ARGS=-C
		svc_cmd "${@}"
		return
	fi
	if command -v svc_pre >${NULL} 2>&1; then
		svc_pre
	fi
	svc_depend || return
	eval exec ${ENV_CMD} ${ENV_OPTS} ${PRE_CMD} ${PRE_OPTS} ${SVC_CMD:-${SVC_NAME}} ${SVC_OPTS}
}

svc_finish()
{
	svc_mark -S
	if command -v svc_post >${NULL} 2>&1; then
		svc_post
	fi
	[ -n "${FIN_CMD}" ] || return 0
	eval exec ${FIN_CMD} ${FIN_OPTS}
}

log_run()
{
	checkpath -q -d ${LOG_MODE:+-m} ${LOG_MODE} \
		${SVC_USER:+-o} ${SVC_USER} ${SVC_GROUP:+-g} ${SVC_GROUP} ${SVC_LOGDIR}

	if command -v log_pre >${NULL} 2>&1; then
		log_pre
	fi
	exec ${PRE_CMD} ${PRE_OPTS} ${LOG_CMD} ${LOG_OPTS}
}

log_finish()
{
	if command -v log_post >${NULL} 2>&1; then
		log_post
	fi
	[ -n "${LOG_FIN_CMD}" ] || return 0
	exec ${LOG_FIN_CMD} ${LOG_FIN_OPTS}
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
