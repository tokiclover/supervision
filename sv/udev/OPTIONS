#
# $Id: @(#) /etc/sv/udev/OPTIONS                                      Exp $
# $L$: 2-clause/new/simplified BSD License                            Exp $
#

SVC_CMD=/sbin/udevd
SVC_OPTS=
SVC_BEFORE='checkfs device-mapper dmcrypt udev-monitor'
SVC_NEED='devfs sysfs'
SVC_PROVIDE='dev'
SVC_STARTED_COMMANDS='reload'
SVC_KEYWORD="lxc supervision vserver"
description="udev device manager daemon"
description_reload="Reload the udev rules and databases"
UDEV_DEBUG=No

udevadm="$(command -v udevadm 2>${NULL})"

start_exec()
{
	${udevadm} control --start-exec-queue --timeout=${UDEV_START_TIMEOUT:-60}
}

reload()
{
	${udevadm} control --reload
}

start_pre()
{
	if ! grep -q devtmpfs /proc/filesystems; then
		if yesno "${USE_MDEV:-YES}"; then
			begin "Starting mdev\n"
			service mdev start
			end "${?}"
		fi
		error "DevtmpFS is not supported"
		return 1
	fi
	if ! mountinfo -q /dev; then
		mount -t devtmpfs -o nosuid,mode=755,size=${DEV_FS_SIZE:-10M} \
			dev /dev >${NULL} 2>&1 ||
			{ error "Failed to setup devtmpfs"; return 2; }
		mkdir -p /dev/pts /dev/shm
	fi
	if [ ! -e /proc/net/unix ]; then
		if ! modprobe unix; then
			error "Failed to load unix domain socket module"
			return 3
		fi
	fi
	if [ -e /proc/sys/kernel/hotplug ]; then
		echo '' >/proc/sys/kernel/hotplug
	fi
	if yesno "${UDEV_DEBUG}"; then
		CMD_OPTS="${CMD_OPTS} --debug 2> /run/udevdebug.log"
	else
		return 0
	fi
}

start_post()
{
	if ! [ -n "${udevadm}" -a -x "${udevadm}" ]; then
		error "No udevadm/udev command found"
		return 1
	fi

	if yesno "${DEV_ROOT_SYMLINK:-1}"; then
		local RULESDIR=/run/udev/rules.d
		mkdir -p ${RULESDIR}
		eval $(udevadm info --export --export-prefix=ROOT_ --device-id-of-file=/)
		if [ -n "${ROOT_MAJOR}" -a -n "${ROOT_MINOR}" -a "${ROOT_MAJOR}" != 0 ]; then
			echo 'ACTION=="add|change", SUBSYSTEM=="block", ENV{MAJOR}=="'${ROOT_MAJOR}'", ENV{MINOR}=="'${ROOT_MINOR}'", SYMLINK+="root"' >${RULESDIR}/61-dev-root-link.rules
		fi
	fi

	#
	# XXX: this necessary to get a function udev early (see BUGS.md)
	#
	local count=1
	begin "Starting to process events"
	while ! start_exec; do
		count=$((${count}+1))
		[ "${count}" = 50 ] && break
		sleep 0.2
	done
	end "${?}"

	begin "Waiting uevents to be processed"
	${udevadm} settle --timeout=${UDEV_SETTLE_TIMEOUT:-60}
	end "${?}"

	begin "Populating /dev with uevents"
	${udevadm} trigger --type=subsystems --action=add
	${udevadm} trigger --type=devices --action=add
	end "${?}"

	return 0
}

stop_pre()
{
	${udevadm} control --exit
}

#
# vim:fenc=utf-8:ft=sv:ci:pi:sts=0:sw=4:ts=4:
#
