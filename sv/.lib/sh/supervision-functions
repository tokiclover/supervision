#
# $Header:  /lib/sv/sh/supervision-functions             Exp $
# $Author: (c) 2015-6 tokiclover <tokiclover@gmail.com>  Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 4.1 2016/10/08 21:09:26                      Exp $
#

__SUPERVIONS_FUNCTIONS__=1

envdir()
{
	${SV_LIBDIR}/bin/envdir "${@}"
}
envuidgid()
{
	${SV_LIBDIR}/bin/envuidgid "${@}"
}
fghack()
{
	${SV_LIBDIR}/bin/fghack "${@}"
}
pgrphack()
{
	${SV_LIBDIR}/bin/pgrphack "${@}"
}
setlock()
{
	${SV_LIBDIR}/bin/setlock "${@}"
}
setuidgid()
{
	${SV_LIBDIR}/bin/setuidgid "${@}"
}
softlimit()
{
	${SV_LIBDIR}/bin/softlimit "${@}"
}

#
# @FUNCTION: Create (supervision) service
# @ARG: [SVC_NAME]
#
svc_new()
{
	local cmd log svc dir

	while [ ${#} -ge 1 ]; do
		case "${1}" in
			(-l|--log)   log=0;;
			(*)   shift; break;;
		esac
		shift
	done
:	${svc:=${1:-${SVC_NAME}}}
:	${dir:=${SV_SVCDIR}/${svc}}

	[ -e "${SV_SVCDIR}/${svc}"  ] && return 0
	mkdir -p "${dir}${log:+/log}"

	for cmd in finish run ${log:+log/run log/finish}; do
		[ -x "${dir}/${cmd}" ] && continue
		[ "${cmd#log/}" != "${cmd}" ] && log=0 || log=
		ln -s ${log:+../}../.opt/cmd "${dir}/${cmd}"
	done
	[ -f ${dir}/OPTIONS ] || sed -e "s|@svc@|${svc}|" \
		${SV_SVCDIR}/.opt/OPTIONS.in >${dir}/OPTIONS
}

svc_down()
{
	case "${1}" in
		(-r|--remove) rm -f "${SV_RUNDIR}/${SVC_NAME}"/down;;
		(-d|--down|*) touch "${SV_RUNDIR}/${SVC_NAME}"/down;;
	esac
}

svc_start()
{
	local val

	svc_state -p && return 0
	#
	# this is done internaly (rs) already
	#
	if yesno "${SVC_WAIT:-1}"; then
	svc_wait -E 5 || eval ${__ERR_BUSY__}
	fi
	cp -HRpu ${SV_SVCDIR}/${SVC_NAME} ${SV_RUNDIR}
	[ -z "${__SCANCMD__}" ] || eval ${__SCANCMD__}

	eval ${__SVCCMD__} ${__SIGWTUP__:-${__SIGSTRT__}} "${SV_RUNDIR}/${SVC_NAME}"
	#
	# XXX: wait five seconds
	#
	svc_wait 5 ${SVC_PIDFILE} && val=0 || val=1
	if [ "${val}" = 0 ]; then
		svc_command start_post || val=2
	fi
	[ "${val}" = 0 ] && svc_mark -s || svc_mark -f
	return ${val}
}

svc_stop()
{
	local val

	svc_state -p || return 0
	#
	# this is done internaly (rs) already
	#
	if yesno "${SVC_WAIT:-1}"; then
	svc_wait -E 5 || eval ${__ERR_BUSY__}
	fi

	svc_command stop_pre || val=2
	eval ${__SVCCMD__} ${__SIGWDWN__:-${__SIGSTOP__}} "${SV_RUNDIR}/${SVC_NAME}"
	if [ "${?}" = 0 ]; then
		svc_mark -S
	else
		val=1
	fi
	return ${val}
}

svc_restart()
{
	svc_stop
	svc_remove
	svc_start
}

svc_status()
{
	svc_state -p && eval ${__CHKCMD__} "${SV_RUNDIR}/${SVC_NAME}" ||
		{ echo -n stopped; return 1; }
}

svc_reload()
{
	if command -v reload >${NULL} 2>&1; then
		reload
	elif [ "${RS_TYPE}" = "rs" ]; then
		error "invalid command -- no reload command definition found"
		return 1
	elif [ -n "${__SIGRELD__}" ]; then
		eval ${__SVCCMD__} ${__SIGRELD__} "${SV_RUNDIR}/${SVC_NAME}"
	else
		eval ${__SVCCMD__} ${__SIGHUP__:-${__SIGEXIT__}} "${SV_RUNDIR}/${SVC_NAME}"
		svc_start
	fi
}

svc_mark()
{
	local arg ret
	for arg; do
		case "${arg}" in
			(-d|--down*)  echo >"${SV_TMPDIR}/down/${SVC_NAME}";;
			(-u|--up*)    rm -f "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-f|--failed) echo >"${SV_TMPDIR}/fail/${SVC_NAME}";;
			(-s|--start*) echo >"${SV_TMPDIR}/star/${SVC_NAME}";;
			(-S|--stoped) rm -f "${SV_TMPDIR}/star/${SVC_NAME}";;
			(*) return ${ret};;
		esac
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

svc_state()
{
	local arg ret
	for arg; do
		case "${arg}" in
			(-e|--exist) [ -e "${SV_SVCDIR}/${SVC_NAME}" ];;
			(-a|--acti*) [ -e "${RS_RUNDIR}/${SVC_NAME}" ];;
			(-f|--fail*) [ -e "${SV_TMPDIR}/fail/${SVC_NAME}" ];;
			(-s|--star*) [ -e "${SV_TMPDIR}/star/${SVC_NAME}" ];;
			(-d|--down*) [ -e "${SV_TMPDIR}/down/${SVC_NAME}" ];;
			(-p|--pid*)  [ -e "${SVC_PIDFILE}" ];;
			(*) return ${ret};;
		esac
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

#
# @FUNCTION: Pre-Run handler
#
svc_config()
{
	local file
	for file in ${SVC_CONFIGFILE} ${SVC_REQ_FILES}; do
		if [ ! -f "${file}" ]; then
			error "${file} required file not found"
			return 1
		fi
	done
}
svc_start_pre()
{
	local SVC_FAILURE val=0
	SVC_FAILURE='{ svc_remove; svc_mark -f; return ${val}; }'

	if ! [ "${SVC_CMD#/}" != "${SVC_CMD}" ]; then
		SVC_CMD=$(command -v ${SVC_CMD:-${SVC_NAME}} 2>${NULL})
	fi
	if ! [ -n "${SVC_CMD}" -a -x "${SVC_CMD}" ]; then
		error "Command not found."
		val=1 eval ${SVC_FAILURE}
	fi
	if ! svc_config; then
		error "Missing configuration files"
		val=2 eval ${SVC_FAILURE}
	fi
	if ! svc_command start_pre; then
		val=3 eval ${SVC_FAILURE}
	fi

	#
	# Set up CGroup
	#
	if [ "${OS_NAME}" = "Linux" ]; then
		if yesno "${SV_CGROUP}"; then
			cgroup_add_service
		fi
	fi
}
svc_remove()
{
	rm -fr "${SV_RUNDIR}/${SVC_NAME}"
	svc_zap
}

#
# @FUNCTION: Pre-Finish handler
#
svc_stop_post()
{
	#
	# Set up CGroup
	#
	if [ "${OS_NAME}" = "Linux" ]; then
		if yesno "${SV_CGROUP}"; then
			cgroup_remove_service
		fi
	fi

	#
	# Handle run return values
	#
	case "${__cmd_args__}" in
		(0*)
		svc_command stop_post
		;;
		(*)
		SVC_TRY=$((${SVC_TRY}+1))
		env_svc SVC_TRY
		if [ ${SVC_TRY:-0} -ge ${SV_TRY:-3} ]; then
			error "Maximum number of starting attempts reached."
			svc_remove
			svc_mark -f
		fi
		;;
	esac
	rm -f ${SVC_PIDFILE} ${SV_TMPDIR}/star/${SVC_NAME}
}

#
# @FUNCTION: Handle service deps
#
svc_depend()
{
	local dep
	if [ "${1}" = "stop" ]; then
		return 0
	else
		dep=1
	fi

	if yesno "${SVC_DEPS:-${dep}}"; then
	for dep in ${__SV_DEPS_ORDER__%before:BEFORE*}; do
		command -v svc_${dep%:*} >${NULL} 2>&1 || continue
		eval svc_${dep%:*} ${1}
		eval RET_${dep#*:}=${?}
	done
	fi

:	${RET_NEED:=0}
	if [ "${RS_TYPE}" = "sv" ]; then
		__SVC_DEPEND__="${RET_NEED}"
		env_svc __SVC_DEPEND__
	fi
	if [ "${RET_NEED}" != 0 ]; then
		error "Failed to set up service dependencies"
	fi
	return ${RET_NEED}
}

svc_need()
{
	[ -n "${SVC_NEDD}" ] || return 0
	svc_use "${1:-start}" "${2:-${SVC_NEED}}"
}
svc_use()
{
	local ret svc
	for svc in ${2:-${SVC_USE}}; do
		rs -q "${svc}" "${1:-start}"
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

#
# @FUNCTION: Set persistent env between run/finish
#
set_env()
{
	local OPT env
	case "${1}" in
		(*_OPTIONS) OPT=${1}; shift;;
		(*) OPT=${SVC_NAME}_OPTIONS;;
	esac
	for env; do
		eval echo "${env}=\"'\$${env}'\""
	done >>"${SV_TMPDIR}/${OPT}"
}
env_svc()
{
	[ -n "${@}" ] && set_env "${SVC_NAME}_OPTIONS" "${@}"
}
env_sv()
{
	[ -n "${@}" ] && set_env "SV_OPTIONS" "${@}"
}
del_env()
{
	local OPT env
	case "${1}" in
		(*_OPTIONS) OPT=${1}; shift;;
		(*) OPT=${SVC_NAME}_OPTIONS;;
	esac
	for env; do
		sed -e "/^${env}=.*$/d" -i ${SV_TMPDIR}/${OPT}
	done
}

env_run()
{
	SOURCE "${SV_TMPDIR}"/${SVC_NAME}_OPTIONS
	SOURCE "${SV_TMPDIR}"/RS_OPTIONS
	SOURCE "${SV_TMPDIR}"/SV_OPTIONS
}

svc_desc()
{
	local desc
	eval desc=\"\${description${1:+_$1}}\"
	if [ -n "${desc}" ]; then
		info ${1:+${1}:} "${desc}"
	else
		warn "No description found"
	fi
}

svc_command()
{
	if command -v ${1} >${NULL} 2>&1 && ! eval ${1}; then
		error "Failed to exec ${1}()"
		return 1
	else
		return 0
	fi
}
#
# @FUNCTION: Handle extra service commands
#
svc_commands()
{
	if [ -z "${SVC_COMMANDS}" ]; then
		error "No extra commands found."
		return 1
	elif [ "${SVC_COMMANDS/${@}}" = "${SVC_COMMANDS}" ]; then
		error "${@} command not found."
		return 2
	fi
	local cmd; cmd=${1}
	if command -v ${cmd} >${NULL} 2>&1; then
		shift
		begin "processing ${cmd} ..."
		eval ${cmd} "${@}"
		end ${?}
	else
		error "${cmd} command not defined."
		return 3
	fi
}

svc_cmd()
{
	local arg cmd opt pfx=svc_ ret
	for arg; do
		case "${1}" in
			(add|del|desc|remove|zap)    cmd=${1} ;;
			(reload|restart|start|stop|status) cmd=${1} ;;
			(cgroup_remove_service) cmd=${1} pfx= ;;
			(*) opt='"${@}"' cmd=commands; break  ;;
		esac
		shift
		opt='"${@}"'
		break
	done

	if [ "${RS_TYPE}" = "rs" ]; then
		case "${cmd}" in
			(start|stop|status) pfx='rs_cmd ';;
		esac
	fi
	case "${cmd}" in
		(add|desc|start)
			svc_state -e || { error "Inexistent service"; return 2; };;
	esac
	begin "service ${cmd}: "
	eval ${pfx}${cmd} ${opt}
	ret="${?}"
	end "${ret}"
	return "${ret}"
}

svc_env()
{
	local dir file
	for dir in ../.env env; do
		[ -d "${SV_RUNDIR}/${dir}" ] && ENV_CMD="${ENV_CMD} envdir ${SV_RUNDIR}/${dir}"
	done
	for file in SVC_USER SVC_GROUP; do
		[ -f "${SV_RUNDIR}/env/${file}" ] && eval ${file}=$(cat "${SV_RUNDIR}/env/${file}")
	done
	ENV_OPTS="${ENV_OPTS} ${SVC_USER:+envuidgid ${SVC_USER}${SVC_GROUP:+:}${SVC_GROUP}}"
}

svc_run()
{
	if [ ${#} -ge 1 ]; then
		svc_cmd "${@}"
		return
	fi
	svc_start_pre || return
	[ "${__SVC_DEPEND__}" = 0 ] || svc_depend || return

	#
	# XXX: workaround for false start failure
	#
	local virtual real=${SV_TMPDIR}/star/${SVC_NAME}
	if [ -n "${SVC_PROVIDE}" ]; then
		virtual=${SV_TMPDIR}/star/${SVC_PROVIDE}
		echo >${virtual}
	fi
	echo >${real}
	echo $$ >${SVC_PIDFILE}

	eval exec ${ENV_CMD} ${ENV_OPTS} ${PRE_CMD} ${PRE_OPTS} ${SVC_CMD:-${SVC_NAME}} ${SVC_OPTS}
	rm -f ${SVC_PIDFILE} ${virtual} ${real}
}

svc_finish()
{
	#
	# XXX: workaround for false start failure
	#
	local virtual real=${SV_TMPDIR}/star/${SVC_NAME}
	if [ -n "${SVC_PROVIDE}" ]; then
		virtual=${SV_TMPDIR}/star/${SVC_PROVIDE}
		echo >${virtual}
	fi
	rm -f ${SVC_PIDFILE} ${virtual} ${real}

	svc_stop_post
	[ -n "${FIN_CMD}" ] || return 0
	eval exec ${FIN_CMD} ${FIN_OPTS}
}

svc_log_run()
{
	checkpath -q -d ${LOG_MODE:+-m} ${LOG_MODE} \
		${SVC_USER:+-o} ${SVC_USER} ${SVC_GROUP:+-g} ${SVC_GROUP} ${SVC_LOGDIR}
	svc_command log_start_pre
	exec ${PRE_CMD} ${PRE_OPTS} ${LOG_CMD} ${LOG_OPTS}
}

svc_log_finish()
{
	svc_command log_stop_post
	[ -n "${LOG_FIN_CMD}" ] || return 0
	exec ${LOG_FIN_CMD} ${LOG_FIN_OPTS}
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
