#
# $Header:  /lib/sv/sh/supervision-functions             Exp $
# $Author: (c) 2015 -tclover <tokiclover@gmail.com>      Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 3.0 2015/04/26 21:09:26                      Exp $
#

#
# @FUNCTION: Create (supervision) service
# @ARG: [SVC_NAME]
#
svc_add()
{
	local args cmd chk dwn log sym svc name dir
	args="$(getopt -o cdls -l check,down,log,service -n add -s sh -- "${@}")"
	[ ${?} = 0 ] || return 128
	eval set -- ${args}

	while [ $# -ge 1 ]; do
		case "${1}" in
			(-c|--check) chk=0;;
			(-d|--down)  dwn=0;;
			(-l|--log)   log=0;;
			(-s|--serv*) svc=0;;
			(*)   shift; break;;
		esac
		shift
	done
:	${name:=${1:-${SVC_NAME}}}
:	${dir=${SV_SVCDIR}/${name}}

	if [ -n "${chk}" ]; then
		if ! type -p ${SVC_CMD:-${name}} >${NULL} 2>&1; then
			error "Command not found."
			return 1
		fi
	fi
	[ -e "${SV_RUNDIR}/${name}"  ] && return 0
	[ -n "${log}" ] && mkdir -p "${dir}"/log || mkdir -p "${dir}"

	for cmd in finish run ${log:+log/run log/finish}; do
		[ -x "${dir}/${cmd}" ] && continue
		[ "${cmd#log/}" != "${cmd}" ] && log=0 || log=
		ln -s ${log:+../}../.opt/cmd "${dir}/${cmd}"
	done
	[ -f ${dir}/OPTIONS ] || sed -e "s|@svc@|${name}|" \
		${SV_SVCDIR}/.opt/OPTIONS.in >${dir}/OPTIONS
	[ -n "${dwn}" ] && svc_down
	[ -n "${svc}" ] || return 0
	case ${SV_RUNDIR} in
		(${SV_SERVICE}) ;;
		(*) cp -LRpu ${dir} ${SV_RUNDIR};;
	esac
	[ -e ${SV_SERVICE}/${name} ] || ln -ns ${dir} ${SV_SERVICE}
	[ -z "${SCANCMD}" ] || eval ${SCANCMD}
}

svc_down()
{
	case "${1}" in
		(-r|--remove) rm -f "${SV_RUNDIR}/${SVC_NAME}"/down;;
		(-d|--down|*) touch "${SV_RUNDIR}/${SVC_NAME}"/down;;
	esac
}

svc_start()
{
	local val

	svc_state -s && eval ${EEND}
	svc_wait 500 || eval ${EBUSY}
	svc_add -s || return 5
	svc_mark  -d

	eval ${SVCCMD} ${SIGWTUP:-${SIGSTRT}} "${SV_RUNDIR}/${SVC_NAME}"
	case ${?} in
		(0) val=0; svc_mark -su;;
		(*) val=5; svc_mark -Su;;
	esac
	svc_down -r
	return ${val}
}

svc_stop()
{
	local val

	svc_state -r || eval ${EEND}
	svc_state -f && eval ${EEND}
	svc_wait 500 || eval ${EBUSY}
	svc_mark  -d

	eval ${SVCCMD} ${SIGWDWN:-${SIGSTOP}} "${SV_RUNDIR}/${SVC_NAME}"
	case ${?} in
		(0) val=0; svc_mark -Su;;
		(*) val=5; svc_mark -fu;;
	esac
	return ${val}
}

svc_status()
{
	eval ${CHKCMD} "${SV_RUNDIR}/${SVC_NAME}"
}

svc_reload()
{
	if [ -n "${SIGRLD}" ]; then
		eval ${SVCCMD} ${SIGRLD} "${SV_RUNDIR}/${SVC_NAME}"
	else
		eval ${SVCCMD} ${SIGHUP:-${SIGEXIT}} "${SV_RUNDIR}/${SVC_NAME}"
		svc_start
	fi
}

svc_mark()
{
	local arg args ret
	args="$(getopt -o Sdfsu -l down,failed,start,stop,up -n mark -s sh -- "${@}")"
	[ ${?} = 0 ] || return 128
	eval set -- ${args}

	for arg in ${@:--s}; do
		case "${arg}" in
			(-d|--down*)  touch "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-u|--up*)    rm -f "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-f|--failed) touch "${SV_TMPDIR}/fail/${SVC_NAME}";;
			(-s|--start*) touch "${SV_TMPDIR}/star/${SVC_NAME}";;
			(-S|--stoped) rm -f "${SV_TMPDIR}/star/${SVC_NAME}";;
			(*) return ${ret};;
		esac
		ret=$((${ret}+${?}))
	done
}

svc_state()
{
	local arg args ret
	args="$(getopt -o defrs -l down,exist,failed,running,start \
		-n state -s sh -- "${@}")"
	[ ${?} = 0 ] || return 128
	eval set -- ${args}

	for arg in ${@:--r}; do
		case "${arg}" in
			(-e|--exist) eval [ -e "\${${SV_SRV}_SVCDIR}/${SVC_NAME}" ];;
			(-r|--runn*) eval [ -e "\${${SV_SRV}_RUNDIR}/${SVC_NAME}" ];;
			(-f|--fail*) [ -e "${SV_TMPDIR}/fail/${SVC_NAME}" ];;
			(-s|--star*) [ -e "${SV_TMPDIR}/star/${SVC_NAME}" ];;
			(-d|--down*) [ -e "${SV_TMPDIR}/down/${SVC_NAME}" ];;
			(*) return ${ret};;
		esac
		ret=$((${ret} + ${?}))
	done
}

#
# @FUNCTION: Pre-Run handler
#
svc_pre()
{
	local REMOVE_SVC file val
	REMOVE_SVC='{ svc_remove; svc_mark -f; return ${val}; }'

	if [ -x ${SVC_DIR}/RUN ]; then
		SVC_CMD=${SVC_DIR}/RUN
	else
		SVC_CMD=$(type -p ${SVC_CMD:-${SVC_NAME}} 2>${NULL})
	fi
	if ! [ -n "${SVC_CMD}" -a -x "${SVC_CMD}" ]; then
		error "Command not found."
		val=1 eval ${REMOVE_SVC}
	fi
	for file in ${SVC_CONFIGFILE} ${SVC_REQ_FILES}; do
		if [ ! -f "${file}" ]; then
			error "${file} required file not found"
			val=2 eval ${REMOVE_SVC}
		fi
	done
	if command -v pre >${NULL} 2>&1; then
		pre || {
			error "Failed to set up service"
			val=3 eval ${REMOVE_SVC}
		}
	fi
}
svc_remove()
{
	eval rm -fr "\${${SV_SRV}_RUNDIR}/${SVC_NAME}"
	svc_zap
}

#
# @FUNCTION: Pre-Finish handler
#
svc_post()
{
	if yesno "${SV_CGROUP}"; then
		cgroup_remove_service
	fi
	if command -v post >${NULL} 2>&1; then
		post || error "Failed to exec post()"
	fi
	#
	# Handle run return values
	#
	case "${cmd_args}" in
		(0*)
		;;
		(*)
		SVC_TRY=$((${SVC_TRY}+1))
		env_svc SVC_TRY
		if [ ${SVC_TRY:-0} -ge ${SV_TRY:-3} ]; then
			error "Maximum number of starting attempts reached."
			svc_remove
			svc_mark -f
		fi
		;;
	esac
}

#
# @FUNCTION: Handle service deps
#
svc_depend()
{
	local DEP dep
	case "${1}" in
		(stop)
	DEP="${SV_SOP_DEP_ORD}" dep=0
		;;
		(*)
	DEP="${SV_SRT_DEP_ORD}" dep=1
		;;
	esac

	yesno ${SVC_DEPS:-${dep}} &&
	for dep in ${DEP}; do
		eval [ -n \"\${SVC_${dep#*:}}\" ] &&
		command -v svc_${dep%:*} >${NULL} 2>&1 || continue
		eval svc_${dep%:*} ${1}
		eval RET_${dep#*:}=${?}
	done

	DEP_RET=${RET_NEED:-0}
	yesno ${RS_STRICT_DEP:-NO} && DEP_RET=$((${DEP_RET}+${RET_AFTER}+${RET_USE}))
	case ${DEP_RET} in
		(0) echo $$ >${SVC_PID};;
		(*) return ${DEP_RET}  ;;
	esac
}

svc_after()
{
	local ret svc SVC
	SVC=${SVC_NAME}
	for svc in ${2-${SVC_AFTER}}; do
		SVC_NAME="${svc}"
		svc_state -s && continue
		svc_state -r && svc_cmd ${1-start}
		ret=$((${ret}+${?}))
	done
	SVC_NAME=${SVC}
	return ${ret}
}

svc_need()
{
	local val
	if ! svc_use ${1-start} "${2-${SVC_NEED}}"; then
		val=${?}
		error "Failed to set up service dependencies."
		return ${val}
	fi
}
svc_use()
{
	local ret svc SVC
	SVC=${SVC_NAME}
	for svc in ${2-${SVC_USE}}; do
		SVC_NAME="${svc}"
		svc_state -f && ret=$((${ret}+1)) || svc_cmd ${1-start}
		ret=$((${ret}+${?}))
	done
	SVC_NAME=${SVC}
	return ${ret}
}

#
# @FUNCTION: Set persistent env between run/finish
#
set_env()
{
	local OPT env; OPT="${1}"
	shift
	for env; do
		eval echo "${env}=\"'\$${env}'\""
		shift
	done >>"${SV_TMPDIR}/${OPT}"
}
env_svc()
{
	[ -n "${@}" ] && set_env "${SVC_NAME}_OPTIONS" "${@}"
}
env_sv()
{
	[ -n "${@}" ] && set_env "SV_OPTIONS" "${@}"
}

#
# @FUNCTION: Set up CGroup
#
svc_cgroup()
{
	if [ -z "${SV_CGROUP}" ]; then
		cgroup_start_sys
		case ${?} in
			(0) SV_CGROUP=Yes;;
			(*) SV_CGROUP=No ;;
		esac
		env_sv SV_CGROUP
	fi
	if yesno "${SV_CGROUP}"; then
		cgroup_add_service
	fi
}

svc_desc()
{
	local desc
	eval desc=\"\${description${1:+_$1}}\"
	if [ -n "${desc}" ]; then
		name=description info "${desc}"
	else
		warn "No description found"
	fi
}

#
# @FUNCTION: Handle extra service commands
#
svc_commands()
{
	if [ -z "${SVC_COMMANDS}" ]; then
		error "No extra commands found."
		return 1
	elif [ "${SVC_COMMANDS/${@}}" = "${SVC_COMMANDS}" ]; then
		error "${@} command not found."
		return 2
	fi
	local cmd; cmd=${1}
	if command -v ${cmd} >${NULL} 2>&1; then
		shift
		begin "processing ${cmd} ..."
		eval ${cmd} "${@}"
		end ${?}
	else
		error "${cmd} command not defined."
		return 3
	fi
}

svc_cmd()
{
	local arg cmd opt pfx; pfx=svc_
	for arg; do
		case "${1}" in
			(add|del|desc|remove|zap)    cmd=${1} ;;
			(reload|start|stop|status) cmd=${1}   ;;
			(cgroup_remove_service) cmd=${1} pfx= ;;
			(*)     opt='"${@}"' cmd=commands     ;;
		esac
		shift
		opt='"${@}"'
		break
	done

	case "${RS_SRV}" in
		(rs)
		case "${cmd}" in
			(add|start|stop|status) pfx='rs_cmd ';;
		esac;;
	esac
	case "${cmd}" in
		(*remove*|reload|stop|status)
			svc_state -r || { error "Inactive service"  ; return 1; };;
		(desc|start)
			svc_state -e || { error "Inexistent service"; return 2; };;
	esac
	begin "service ${cmd}: "
	eval ${pfx}${cmd} ${opt}
	end "${?}"
}

svc_env()
{
	local dir file
	for dir in ../.env env; do
		[ -d "${SV_RUNDIR}/${dir}" ] && ENV_CMD="${ENV_CMD} envdir ${SV_RUNDIR}/${dir}"
	done
	for file in SVC_USER SVC_GROUP; do
		[ -f "${SV_RUNDIR}/env/${file}" ] && eval ${file}=$(cat "${SV_RUNDIR}/env/${file}")
	done
	ENV_OPTS="${ENV_OPTS} ${SVC_USER:+envuidgid ${SVC_USER}${SVC_GROUP:+:}${SVC_GROUP}}"
}

svc_run()
{
	if [ ${#} -ge 1 ]; then
		ARGS=-C
		svc_cmd "${@}"
		return
	fi
	if command -v svc_pre >${NULL} 2>&1; then
		svc_pre || return
	fi
	svc_depend || return
	eval exec ${ENV_CMD} ${ENV_OPTS} ${PRE_CMD} ${PRE_OPTS} ${SVC_CMD:-${SVC_NAME}} ${SVC_OPTS}
}

svc_finish()
{
	svc_mark -S
	if command -v svc_post >${NULL} 2>&1; then
		svc_post
	fi
	[ -n "${FIN_CMD}" ] || return 0
	eval exec ${FIN_CMD} ${FIN_OPTS}
}

log_run()
{
	checkpath -q -d ${LOG_MODE:+-m} ${LOG_MODE} \
		${SVC_USER:+-o} ${SVC_USER} ${SVC_GROUP:+-g} ${SVC_GROUP} ${SVC_LOGDIR}

	if command -v log_pre >${NULL} 2>&1; then
		log_pre
	fi
	exec ${PRE_CMD} ${PRE_OPTS} ${LOG_CMD} ${LOG_OPTS}
}

log_finish()
{
	if command -v log_post >${NULL} 2>&1; then
		log_post
	fi
	[ -n "${LOG_FIN_CMD}" ] || return 0
	exec ${LOG_FIN_CMD} ${LOG_FIN_OPTS}
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
