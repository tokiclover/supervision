#
# $Header:  /lib/sv/sh/supervision-functions             Exp $
# $Author: (c) 2015-6 tokiclover <tokiclover@gmail.com>  Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 3.3 2016/07/07 21:09:26                      Exp $
#

__SUPERVIONS_FUNCTIONS__=1

#
# @FUNCTION: Create (supervision) service
# @ARG: [SVC_NAME]
#
svc_add()
{
	local cmd log svc name dir

	while [ $# -ge 1 ]; do
		case "${1}" in
			(-l|--log)   log=0;;
			(-s|--serv*) svc=0;;
			(*)   shift; break;;
		esac
		shift
	done
:	${name:=${1:-${SVC_NAME}}}
:	${dir:=${SV_SVCDIR}/${name}}

	[ -e "${SV_RUNDIR}/${name}"  ] && return 0
	[ -n "${log}" ] && mkdir -p "${dir}"/log || mkdir -p "${dir}"

	for cmd in finish run ${log:+log/run log/finish}; do
		[ -x "${dir}/${cmd}" ] && continue
		[ "${cmd#log/}" != "${cmd}" ] && log=0 || log=
		ln -s ${log:+../}../.opt/cmd "${dir}/${cmd}"
	done
	[ -f ${dir}/OPTIONS ] || sed -e "s|@svc@|${name}|" \
		${SV_SVCDIR}/.opt/OPTIONS.in >${dir}/OPTIONS

	[ -n "${svc}" ] || return 0
	[ -e ${SV_SERVICE}/${name} ] || ln -ns ${dir} ${SV_SERVICE}
}

svc_down()
{
	case "${1}" in
		(-r|--remove) rm -f "${SV_RUNDIR}/${SVC_NAME}"/down;;
		(-d|--down|*) touch "${SV_RUNDIR}/${SVC_NAME}"/down;;
	esac
}

svc_start()
{
	local val

	svc_state -p && eval ${__ERR_END__}
	#
	# this is done internaly (rs) already
	#
	if [ -z "${RS_STAGE}" ]; then
	svc_wait 500 || eval ${__ERR_BUSY__}
	fi
	cp -LRpu ${SV_SVCDIR}/${SVC_NAME} ${SV_RUNDIR}
	[ -z "${__SCANCMD__}" ] || eval ${__SCANCMD__}
	svc_mark -d

	eval ${__SVCCMD__} ${__SIGWTUP__:-${__SIGSTRT__}} "${SV_RUNDIR}/${SVC_NAME}"
	val="${?}"
	case "${val}" in
		(0) val=0; svc_mark -s -u;;
		(*) val=5; svc_mark -S -u;;
	esac
	svc_down -r
	return ${val}
}

svc_stop()
{
	local val

	svc_state -p || eval ${__ERR_END__}
	#
	# this is done internaly (rs) already
	#
	if [ -z "${RS_STAGE}" ]; then
	svc_wait 500 || eval ${__ERR_BUSY__}
	fi
	svc_mark  -d

	eval ${__SVCCMD__} ${__SIGWDWN__:-${__SIGSTOP__}} "${SV_RUNDIR}/${SVC_NAME}"
	val="${?}"
	case "${val}" in
		(0) val=0; svc_mark -S -u;;
		(*) val=5; svc_mark -f -u;;
	esac
	return ${val}
}

svc_status()
{
	svc_state -p && eval ${__CHKCMD__} "${SV_RUNDIR}/${SVC_NAME}" ||
		{ echo -n stopped; return 1; }
}

svc_reload()
{
	if [ -n "${__SIGRELD__}" ]; then
		eval ${__SVCCMD__} ${__SIGRLD__} "${SV_RUNDIR}/${SVC_NAME}"
	else
		eval ${__SVCCMD__} ${__SIGHUP__:-${__SIGEXIT__}} "${SV_RUNDIR}/${SVC_NAME}"
		svc_start
	fi
}

svc_mark()
{
	local arg ret

	for arg in ${@:--s}; do
		case "${arg}" in
			(-d|--down*)  touch "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-u|--up*)    rm -f "${SV_TMPDIR}/down/${SVC_NAME}";;
			(-f|--failed) touch "${SV_TMPDIR}/fail/${SVC_NAME}";;
			(-s|--start*) touch "${SV_TMPDIR}/star/${SVC_NAME}";;
			(-S|--stoped) rm -f "${SV_TMPDIR}/star/${SVC_NAME}";;
			(*) return ${ret};;
		esac
		ret=$((${ret}+${?}))
	done
	return "${ret}"
}

svc_state()
{
	local arg ret

	for arg in ${@:--r}; do
		case "${arg}" in
			(-e|--exist) eval [ -e "\${${SV_TYPE}_SVCDIR}/${SVC_NAME}" ];;
			(-r|--runn*) eval [ -e "\${${SV_TYPE}_RUNDIR}/${SVC_NAME}" ];;
			(-f|--fail*) [ -e "${SV_TMPDIR}/fail/${SVC_NAME}" ];;
			(-s|--star*) [ -e "${SV_TMPDIR}/star/${SVC_NAME}" ];;
			(-d|--down*) [ -e "${SV_TMPDIR}/down/${SVC_NAME}" ];;
			(-p|--pid*)  [ -e "${SVC_PIDFILE}" ];;
			(*) return ${ret};;
		esac
		ret=$((${ret} + ${?}))
	done
	return "${ret}"
}

#
# @FUNCTION: Pre-Run handler
#
svc_pre()
{
	local REMOVE_SVC file val
	REMOVE_SVC='{ svc_remove; svc_mark -f; return ${val}; }'

	if [ -x ${SVC_DIR}/RUN ]; then
		SVC_CMD=${SVC_DIR}/RUN
	else
		SVC_CMD=$(command -v ${SVC_CMD:-${SVC_NAME}} 2>${NULL})
	fi
	if ! [ -n "${SVC_CMD}" -a -x "${SVC_CMD}" ]; then
		error "Command not found."
		val=1 eval ${REMOVE_SVC}
	fi
	for file in ${SVC_CONFIGFILE} ${SVC_REQ_FILES}; do
		if [ ! -f "${file}" ]; then
			error "${file} required file not found"
			val=2 eval ${REMOVE_SVC}
		fi
	done
	if command -v pre >${NULL} 2>&1; then
		pre || {
			error "Failed to set up service"
			val=3 eval ${REMOVE_SVC}
		}
	fi

	#
	# Set up CGroup
	#
	case "${OS_NAME}" in
		(Linux)
		if yesno "${SV_CGROUP}"; then
			cgroup_add_service
		fi
		;;
	esac
}
svc_remove()
{
	eval rm -fr "\${${SV_TYPE}_RUNDIR}/${SVC_NAME}"
	svc_zap
}

#
# @FUNCTION: Pre-Finish handler
#
svc_post()
{
	#
	# Set up CGroup
	#
	case "${OS_NAME}" in
		(Linux)
		if yesno "${SV_CGROUP}"; then
			cgroup_remove_service
		fi
		;;
	esac

	if command -v post >${NULL} 2>&1; then
		post || error "Failed to exec post()"
	fi
	#
	# Handle run return values
	#
	case "${__cmd_args__}" in
		(0*)
		;;
		(*)
		SVC_TRY=$((${SVC_TRY}+1))
		env_svc SVC_TRY
		if [ ${SVC_TRY:-0} -ge ${SV_TRY:-3} ]; then
			error "Maximum number of starting attempts reached."
			svc_remove
			svc_mark -f
		fi
		;;
	esac
	rm -f ${SVC_PIDFILE}
}

#
# @FUNCTION: Handle service deps
#
svc_depend()
{
	local dep
	case "${1}" in
		(stop)
	return 0;
		;;
		(*)
	dep=1
		;;
	esac

	yesno ${SVC_DEPS:-${dep}} &&
	for dep in ${__SV_DEPS_ORDER__/before:BEFORE/}; do
		command -v svc_${dep%:*} >${NULL} 2>&1 || continue
		eval svc_${dep%:*} ${1}
		eval RET_${dep#*:}=${?}
	done

	DEP_RET=${RET_NEED:-0}
	yesno ${RS_STRICT_DEP:-NO} && DEP_RET=$((${DEP_RET}+${RET_AFTER}))
	return ${DEP_RET}
}

svc_after()
{
	local ret svc
	for svc in ${2-${SVC_AFTER}}; do
		rs -q "${svc}" "${1:-start}"
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

svc_need()
{
	local val
	[ -n "${SVC_NEDD}" ] || return 0
	svc_use "${1:-start}" "${2:-${SVC_NEED}}"
	val="${?}"
	[ "${val}" -gt 0 ] && error "Failed to set up service dependencies"
	return "${val}"
}
svc_use()
{
	local ret svc
	for svc in ${2:-${SVC_USE}}; do
		rs -q "${svc}" "${1:-start}"
		ret=$((${ret}+${?}))
	done
	return ${ret}
}

#
# @FUNCTION: Set persistent env between run/finish
#
set_env()
{
	local OPT env
	case "${1}" in
		(*_OPTIONS) OPT=${1}; shift;;
		(*) OPT=${SVC_NAME}_OPTIONS;;
	esac
	for env; do
		eval echo "${env}=\"'\$${env}'\""
	done >>"${SV_TMPDIR}/${OPT}"
}
env_svc()
{
	[ -n "${@}" ] && set_env "${SVC_NAME}_OPTIONS" "${@}"
}
env_sv()
{
	[ -n "${@}" ] && set_env "SV_OPTIONS" "${@}"
}
del_env()
{
	local OPT env
	case "${1}" in
		(*_OPTIONS) OPT=${1}; shift;;
		(*) OPT=${SVC_NAME}_OPTIONS;;
	esac
	for env; do
		sed -e "/^${env}=.*$/d" -i ${SV_TMPDIR}/${OPT}
	done
}

svc_desc()
{
	local desc
	eval desc=\"\${description${1:+_$1}}\"
	if [ -n "${desc}" ]; then
		name=description info "${desc}"
	else
		warn "No description found"
	fi
}

#
# @FUNCTION: Handle extra service commands
#
svc_commands()
{
	if [ -z "${SVC_COMMANDS}" ]; then
		error "No extra commands found."
		return 1
	elif [ "${SVC_COMMANDS/${@}}" = "${SVC_COMMANDS}" ]; then
		error "${@} command not found."
		return 2
	fi
	local cmd; cmd=${1}
	if command -v ${cmd} >${NULL} 2>&1; then
		shift
		begin "processing ${cmd} ..."
		eval ${cmd} "${@}"
		end ${?}
	else
		error "${cmd} command not defined."
		return 3
	fi
}

svc_cmd()
{
	local arg cmd opt pfx=svc_ ret
	for arg; do
		case "${1}" in
			(add|del|desc|remove|zap)    cmd=${1} ;;
			(reload|start|stop|status) cmd=${1}   ;;
			(cgroup_remove_service) cmd=${1} pfx= ;;
			(*) opt='"${@}"' cmd=commands; break  ;;
		esac
		shift
		opt='"${@}"'
		break
	done

	case "${RS_TYPE}" in
		(rs)
		case "${cmd}" in
			(add|start|stop|status) pfx='rs_cmd ';;
		esac;;
	esac
	case "${cmd}" in
		(desc|start)
			svc_state -e || { error "Inexistent service"; return 2; };;
	esac
	begin "service ${cmd}: "
	eval ${pfx}${cmd} ${opt}
	ret="${?}"
	end "${ret}"
	return "${ret}"
}

svc_env()
{
	local dir file
	for dir in ../.env env; do
		[ -d "${SV_RUNDIR}/${dir}" ] && ENV_CMD="${ENV_CMD} envdir ${SV_RUNDIR}/${dir}"
	done
	for file in SVC_USER SVC_GROUP; do
		[ -f "${SV_RUNDIR}/env/${file}" ] && eval ${file}=$(cat "${SV_RUNDIR}/env/${file}")
	done
	ENV_OPTS="${ENV_OPTS} ${SVC_USER:+envuidgid ${SVC_USER}${SVC_GROUP:+:}${SVC_GROUP}}"
}

svc_run()
{
	if [ ${#} -ge 1 ]; then
		svc_cmd "${@}"
		return
	fi
	if command -v svc_pre >${NULL} 2>&1; then
		svc_pre || return
	fi
	svc_depend || return
	echo $$ >${SVC_PIDFILE}
	eval exec ${ENV_CMD} ${ENV_OPTS} ${PRE_CMD} ${PRE_OPTS} ${SVC_CMD:-${SVC_NAME}} ${SVC_OPTS}
	rm -f ${SVC_PIDFILE}
}

svc_finish()
{
	svc_mark -S
	if command -v svc_post >${NULL} 2>&1; then
		svc_post
	fi
	rm -f ${SVC_PIDFILE}
	[ -n "${FIN_CMD}" ] || return 0
	eval exec ${FIN_CMD} ${FIN_OPTS}
}

log_run()
{
	checkpath -q -d ${LOG_MODE:+-m} ${LOG_MODE} \
		${SVC_USER:+-o} ${SVC_USER} ${SVC_GROUP:+-g} ${SVC_GROUP} ${SVC_LOGDIR}

	if command -v log_pre >${NULL} 2>&1; then
		log_pre
	fi
	exec ${PRE_CMD} ${PRE_OPTS} ${LOG_CMD} ${LOG_OPTS}
}

log_finish()
{
	if command -v log_post >${NULL} 2>&1; then
		log_post
	fi
	[ -n "${LOG_FIN_CMD}" ] || return 0
	exec ${LOG_FIN_CMD} ${LOG_FIN_OPTS}
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
