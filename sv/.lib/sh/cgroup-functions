#
# $Header:  /lib/sv/sh/cgroup-functions                  Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.0 2015/05/04                               Exp $
#
# Copyright (c) 2012 Alexander Vershilov <qnikst@gentoo.org>
# CopyLetf  (c) 2015 -tclover <tokiclover@gmail.com>
#

:	${CG_NAME=supervision}
:	${CG_ROOT=/sys/fs/cgroup}
:	${CG_PATH=${CG_ROOT}/${CG_NAME}}
:	${SYSFS_OPTS=nodev,nosuid,noexec}
:	${CG_RELEASE_AGENT=${SV_LIBDIR}/sh/cgroup-release-agent}

cgroup_start_sys()
{
	${RS_SVCDIR}/sysfs mount_cgroup || return 1

	local opt
	[ -w /etc/mtab ] || opt=-n
	if ! mount_info ${CG_PATH}; then
		mkdir -p ${CG_PATH}
		mount ${opt} -o none,${SYSFS_OPTS},name=${CG_NAME},release_agent=${CG_RELEASE_AGENT} \
			-t cgroup  ${CG_NAME} ${CG_PATH}
		echo 1 > ${CG_PATH}/notify_on_release
	fi
}

cgroup_find_path()
{
	local ifs DIR ctrl dir n
	[ -n "${1}" ] || return 0
	ifs="${IFS}"; IFS=":"
	while read n ctrl dir; do
		[ "${ctrl}" = "${1}" ] && DIR="${dir}"
	done < /proc/1/cgroup
	IFS="${ifs}"
	echo "${DIR}"
}

cgroup_get_pids()
{
	local p
	PIDS=
	while read p; do
		[ ${p} -eq $$ ] || PIDS="${PIDS} ${p}"
	done < ${CG_PATH}/${SVC_NAME}/tasks
	[ -n "${PIDS}" ]
}

cgroup_get_state()
{
	[ -d "${CG_PATH}/${SVC_NAME}" ]
}

cgroup_set_values()
{
	[ -n "${1}" -a -n "${2}" -a -d "${CG_ROOT}/${1}" ] || return 0

	local group head ctrl
	ctrl="${1}"; head=$(cgroup_find_path "${1}")
	group="${CG_ROOT}/${1}${head}${CG_NAME}_${SVC_NAME}"
	[ -d "${group}" ] || mkdir -p "${group}"

	set -- ${2}
	local prm val
	while [ -n "${1}" -a "${ctrl}" != "cpuacct" ]; do
		case "${1}" in
			(${ctrl}.*)
				if [ -n "${prm}" -a -f "${group}/${prm}" -a -n "${val}" ]; then
					info "Setting ${group}/${prm} to ${val}"
					echo "${val}" > "${group}/${prm}"
				fi
				prm="${1}"; val=
				;;
			(*)
				val="${val} ${1}"
				;;
		esac
		shift
	done
	if [ -n "${prm}" -a -f "${group}/${prm}" -a -n "${val}" ]; then
		info "Setting ${group}/${prm} to ${val}"
		echo "${val}" > "${group}/${prm}"
	fi
	if [ -f "${group}/tasks" ]; then
		info "Adding to ${group}/tasks"
		echo $$ > "${group}/tasks"
	fi
	return 0
}

cgroup_add_service()
{
	#
	# FIXME:
	# Relocating process to the top of the CGroup to prevent
	# unwanted inheriting user CGroup may lead to issue when
	# inheriting may be necessary.
	#
	if yesno ${cgroup_inherit:-${CGROUP_INHERIT}}; then
		local dir
		for dir in ${CG_ROOT}/*; do
			[ -f "${dir}"/tasks ] && echo $$ > "${dir}"/tasks
		done
	fi

	if [ -d "${CG_PATH}" ]; then
		local group
		group="${CG_PATH}/${SVC_NAME}"
		mkdir -p "${group}"
		[ -f "${group}/tasks" ] && echo $$ > "${group}/tasks"
	fi
}

cgroup_set_limits()
{
	local ctrl blkio cpu cpuacct cpuset devices memory net_prio

	for ctrl in blkio:BLKIO cpu:CPU cpuacct:CPUACCT cpuset:CPUSET \
		devices:DEVICES memory:MEMORY net_prio:NET_PRIO; do
		eval ${ctrl%:*}=\"\${cgroup_${ctrl%:*}:-\${CGROUP_${ctrl#*:}}}\"
		eval [ -n \"\${${ctrl%:*}}\" ] && cgroup_set_values "${ctrl%:*}" "\${${ctrl%:*}}"
	done
	return 0
}

cgroup_remove_service()
{
	cgroup_get_state || return 0
	yesno "${cgroup_cleanup:-${CGROUP_CLEANUP}}" || return 0
	local CGROUP_GET_PIDS SIG
	CGROUP_GET_PIDS='cgroup_get_pids || { end 0; return 0; };'

	begin "Cleaning up CGroup"
	for SIG in TERM QUIT INT; do
		eval ${CGROUP_GET_PIDS}
		kill -${SIG} ${PIDS}
	done
	eval ${CGROUP_GET_PIDS}
	kill -TERM ${PIDS}
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
