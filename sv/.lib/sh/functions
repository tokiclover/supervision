#
# $Header:  /lib/sv/sh/functions                         Exp $
# $Author: (c) 2015-6 tokiclover <tokiclover@gmail.com>  Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.3 2016/05/08 21:09:26                      Exp $
#

__FUNCTIONS__=1

#
# ZSH compatibility
#
if [ -n "${ZSH_VERSION}" ]; then
	emulate sh
	setopt SH_WORD_SPLIT
	disable -r end
fi

#
# Setup a few environment variables beforehand
#
:	${COLUMNS:=$(tput cols)}

#
# @FUNCTION: Print error message to stderr
#
error()
{
	local msg="${*}"
	PRINT_LEN=$((${#name}+3+${#msg}))
	local pfx="${name:+${COLOR_MAG}${name}:${COLOR_RST}}"
	echo -e "${PRINT_EOL}${COLOR_RED}*${COLOR_RST} ${pfx} ${@}" >&2
}

#
# @FUNCTION: Print error message to stderr & exit
#
die()
{
	local ret=${?}; pr_error "${@}"; exit ${ret}
}

#
# @FUNCTION: Print info message to stdout
#
info()
{
	local msg="${*}"
	PRINT_LEN=$((${#name}+3+${#msg}))
	local pfx="${name:+${COLOR_YLW}${name}:${COLOR_RST}}"
	echo -e "${PRINT_EOL}${COLOR_BLU}*${COLOR_RST} ${pfx} ${@}"
}

#
# @FUNCTION: Print warn message to stdout
#
warn()
{
	local msg="${*}"
	PRINT_LEN=$((${#name}+3+${#msg}))
	local pfx="${name:+${COLOR_RED}${name}:${COLOR_RST}}"
	echo -e "${PRINT_EOL}${COLOR_YLW}*${COLOR_RST} ${pfx} ${@}"
}

#
# @FUNCTION: Print begin message to stdout
#
begin()
{
	echo -en "${PRINT_EOL}"
	PRINT_EOL="\n"
	local msg="${*}"
	PRINT_LEN=$((${#name}+3+${#msg}))
	local pfx="${name:+${COLOR_MAG}[${COLOR_BLU}${name}${COLOR_MAG}]${COLOR_RST}}"
	echo -en "${pfx} ${@}"
}

#
# @FUNCTION: Print end message to stdout
#
end()
{
	local suffix
	case "${1-0}" in
		(0) suffix="${COLOR_BLU}[${COLOR_GRN}ok${COLOR_BLU}]${COLOR_RST}";;
		(*) suffix="${COLOR_YLW}[${COLOR_RED}no${COLOR_YLW}]${COLOR_RST}";;
	esac
	shift
	PRINT_LEN=$((${COLUMNS}-${PRINT_LEN}))
	printf "%*b\n" "${PRINT_LEN}" "${@} ${suffix}"
	PRINT_EOL=
	PRINT_LEN=0
}

#
# @FUNCTION: YES or NO helper
#
yesno()
{
	case "${1:-NO}" in
	(0|[Dd][Ii][Ss][Aa][Bb][Ll][Ee]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee]|[Nn][Oo])
		return 1;;
	(1|[Ee][Nn][Aa][Bb][Ll][Ee]|[Oo][Nn]|[Tt][Rr][Uu][Ee]|[Yy][Ee][Ss])
		return 0;;
	(*)
		return 2;;
	esac
}

#
# @FUNCTION: source wrapper
# @ARG: [OPT] FILE
#
SOURCE()
{
	local arg msg opt ret
	msg='Failed to source ${arg}'
	while [ ${#} -ge 1 ]; do
		case "${1}" in
			(-[ed]) opt=${1};;
			(*) break;;
		esac
		shift
	done

	for arg; do
	[ -e "${1}" ] && source "${1}"
	case "${?}" in
		(0)
			;;
		(*)
			ret=$((${ret} + ${?}))
			case "${opt}" in
				(-e) eval error \"${msg}\";;
				(-d) eval die   \"${msg}\";;
			esac
			;;
	esac
	shift
	done
	return ${ret}
}

#
# @FUNCTION: Colors handler
#
eval_colors()
{
	local ESC FGD BGD color
	ESC='\e[' FGD='3' BGD='4'

	for color in 0:BLK 1:RED 2:GRN 3:YLW 4:BLU 5:MAG 6:CYN 7:WHT; do
		eval COLOR_${color#*:}="'${ESC}${FGD}${color%:*}m'"
		eval COLOR_BG_${color#*:}="'${ESC}${BGD}${color%:*}m'"
	done
	COLOR_RST="${ESC}0m"
	COLOR_BLD="${ESC}1m"
	COLOR_UND="${ESC}4m"
	COLOR_ITA="${ESC}3m"
	if [ "${1}" = 256 ]; then
		local i
		for i in seq 0 255; do
			eval BG_${i}="'${ESC}${BGD}${i}m'"
			eval FG_${i}="'${ESC}${FGD}${i}m'"
		done
	fi
}

if [ -t 1 ] && yesno "${COLOR:-Yes}"; then
	eval_colors
fi

#
# @FUNCTION: Mount/fstab info helper
# @ARG: [OPTIONS] DIR
#
mount_info()
{
	local arg args fs src opts opt ret

	src=/proc/mounts
	args="$(getopt -o F:fo: -l fstab,fsys:,options: -n mount_info -s sh -- "${@}")"
	eval set -- ${args}

	while true; do
	case "${1}" in
		(-f|--fstab) src=/etc/fstab;;
		(-F|--fsys*) fs="${2}"; shift;;
		(-o|--options) opts="${2}"; shift;;
		(*) shift; break;;
	esac
	shift
	done

	arg="${1}"
	eval set -- $(sed -nre "s|(^[^#].*${1}[[:space:]].*${fs})[[:space:]].*$|\1|p" ${src})
	[ -z "${1}" ] && return 1

	if [ -n "${opts}" ]; then
		local IFS="${IFS},"
		for opt in ${opts}; do
			case "${opts}" in
				(*${opt}*)  ;;
				(*) return 1;;
			esac
		done
	fi

	case "${arg}" in
		(${1}|${2}) return 0;;
	esac
	return 1
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
