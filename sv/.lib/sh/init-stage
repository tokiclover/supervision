#!/bin/sh
#
# $Header:  /lib/sv/sh/init-stage                        Exp $
# $Author: (c) 2015-6 tokiclover <tokiclover@gmail.com>  Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.4 2016/08/06                               Exp $
#

:	${name=${0##*/}}
:	${SV_LIBDIR:=${0%/sh/*}}
source "${0%/*}"/runscript-functions ||
	{ echo "Required file not found." >&2; exit 1; }
source ${SV_SVCDIR}/.opt/SVC_BACKEND
source ${SV_SVCDIR}.conf
umask 022

SV_CMD="${__SV_CMD__##*/}"

early_console()
{
	[ -d ${SV_LIBDIR}/cache ] || return

	local encoding='%@' args kbd_args=-a keymap consolefont
	if [ -e ${SV_LIBDIR}/cache/unicode ]; then
		encoding='%G' kbd_args=-u
	fi
:	${CONSOLE:=/dev/console}
	printf "\033${encoding}" >${CONSOLE}

	[ -c ${CONSOLE} ] && args="-C ${CONSOLE}"
	consolefont=${SV_LIBDIR}/cache/font+umap
	[ -s ${consolefont} ] && setfont ${args} ${consolefont} 2>${NULL}

	[ -n "${args}" ] && kbd_mode ${kbd_args} ${args}
	keymap=${SV_LIBDIR}/cache/keymap
	[ -s ${keymap} ] && loadkeys -q ${keymap} 2>${NULL}
}

svc_init()
{
	local dir opt procfs OS_NAME="$(uname -s)"
	[ -w /etc/mtab ] || opt=-n

	if   [ "${OS_NAME}" = "GNU/kFreeBSD" ]; then
		procfs=linprocfs
	else
		procfs=proc
	fi

	if ! mountinfo --quiet /proc 2>${NULL}; then
		begin "Mounting /proc"
		mount ${opt} -t ${procfs} -o ${SYSFS_OPTS:-nodev} proc /proc
		end ${?}
	fi

	if [ "${OS_NAME}" = "Linux" ]; then
	if [ ! -d /run ]; then
		begin "Creating /run"
		mkdir -m 0755 -p /run
		end ${?}
	fi
	if ! mountinfo --quiet /run; then
		begin "Mounting /run"
		mount ${opt} -t tmpfs -o nodev,mode=755,size=${RUN_FS_SIZE:-1%} run /run
		end ${?}
	fi
	fi # OS_NAME=Linux

	#
	# XXX: Add some insurance to get a few services started early (e.g. lvm
	#   needs /run/lock/lvm which is started before miscfs.) Who need lvm
	#   for `/var'? Nothing will ever... well, it will with some hassle.
	#
	for dir in /var/run /var/lock; do
		[ -L "${dir}" ] || continue
		dir="$(readlink ${dir})"
		case "${dir}" in
			(/run*)
			begin "Creating ${dir}"
			mkdir -m 0755 -p "${dir}"
			end ${?}
			;;
		esac
	done

	[ -d "${SV_RUNDIR}" ] || svc_tmpdir
}

svc_rsh()
{
:	${RS_SHELL:=${SHELL:-sh}}
	if [ "${RS_SHELL##*/}" = "sulogin" ]; then
		exec ${RS_SHELL} -p /dev/tty8
	fi
	[ "${OS_NAME}" = "Linux" ] && exec sulogin -p /dev/tty8
	exec 2>&1
	exec ${RS_SHELL} -aim
	exec sh -aim
	exec busybox sh -aim
	error "No functional shell found!!!"
}

svc_tmpdir()
{
	rm -fr "${SV_TMPDIR}"
	mkdir -p "${SV_TMPDIR}"
	ln -fs "${SV_SVCDIR}"/.opt "${SV_RUNDIR}"
	ln -fs "${SV_LIBDIR}" "${SV_RUNDIR}"/.lib
	mkdir -p "${SV_TMPDIR}"/down "${SV_TMPDIR}"/deps "${SV_TMPDIR}"/fail \
		"${SV_TMPDIR}"/pids "${SV_TMPDIR}"/star "${SV_TMPDIR}"/wait
	#
	# Initialization
	#
	echo "${__SV_NAM__}:${SV_CMD}" >"${SV_TMPDIR}"/sv
	OS_NAME=$(uname -s)
	env_sv OS_NAME

	#
	# Set up CGroup
	#
	if yesno ${SV_CGROUP:-YES}; then
		rs devfs start &
		rs sysfs start
		cgroup_start_sys
		case ${?} in
			(0) SV_CGROUP=Yes;;
			(*) SV_CGROUP=No ;;
		esac
		env_sv SV_CGROUP
	fi
}

kill_svscan()
{
	local pid umount_proc=false

	if [ "${OS_NAME}" =      "FreeBSD" ]; then
		if ! mountinfo --quiet /proc; then
			mount -t procfs proc /proc || return
			umount_proc=true
		fi
	fi

	for pid in $(pgrep "${SV_CMD}"); do
		read cmdline </proc/${pid}/cmdline
		case "${cmdline}" in
			(*${SV_RUNDIR}*) break;;
			(*) pid=;;
		esac
	done
	[ -n "${pid}" ] && kill -TERM ${pid} 2>${NULL}

	${umount_proc} && umount /proc
}

case ${SV_CMD} in
	(runsvdir)
:	${SV_OPTS:=log:...........................................................}
	;;
esac

pidfile="${SV_TMPDIR}/${SV_CMD}.pid"
begin "Starting Init-Stage${1}\n"
if   [ "${1}" = "-0" ]; then
	[ -d "${SV_RUNDIR}" ] || svc_tmpdir
	if [ -e "${pidfile}" ]; then
		kill_svscan
	fi
	echo $$ >${pidfile}
	${__SV_CMD__} ${SV_RUNDIR} ${SV_OPTS} &
elif [ "${1}" = "-1" ]; then
	early_console
	svc_init
	rs -0 stage
elif [ "${1}" = "-2" ]; then
	[ -d "${SV_RUNDIR}" ] || svc_tmpdir
	#
	# Set up CGroup
	#
	if [ "${OS_NAME}" = "Linux" ]; then
		SVC_NAME="${SV_CMD}" cgroup_add_service
	fi
	#
	# Bring up what left and stage-2 assuming `svcscan'
	# is ready when the following pidfile is present
	#
	if [ -e "${pidfile}" ]; then
		kill_svscan
		rm ${pidfile}
	fi
	#
	# XXX: This hackery is necessary to get the real pid;
	# this is used to send SIGCONT to runsvdir.
	#
	sh -c "source ${SV_LIBDIR}/sh/runscript-functions;
		pidfile=${pidfile}; pid=; count=0; SVC_NAME=${SV_CMD};
		svc_wait 10 ${pidfile};
		if [ ${SV_CMD} = runsvdir ]; then
		while [ -e ${pidfile} ]; do
			for pid in \$(pgrep ${SV_CMD}); do
				read cmdline </proc/\${pid}/cmdline;
				case \${cmdline} in
					(*${SV_RUNDIR}*) echo \${pid} >${pidfile}; break 2;;
				esac;
			done;
			sleep 0.1;
			count=\$((\${count}+1));
			[ \${count} = 100 ] && break;
		done;
		fi;
		rs -1 stage; rs -2 stage;" &

	echo $$ >${pidfile}
	exec ${__SV_CMD__} ${SV_RUNDIR} ${SV_OPTS}
	#
	# Drop into a rescue shell
	#
	svc_rsh
elif [ "${1}" = "-3" ]; then
	rs -3 stage

	#
	# CGroup clean up
	#
	if  [ "${OS_NAME}" = "Linux" ]; then
		SVC_NAME="${SV_CMD}" cgroup_remove_service
	fi
	#
	# Use this safety net in case daemontools(-encore) is used
	#
	if [ "${__SV_NAM__%-*}" = "daemontools" ]; then
		ACTION="${ACTION:+--${ACTION}}"
		sv-shutdown --force ${ACTION:---shutdown}
	fi
fi
end "${?}"

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
