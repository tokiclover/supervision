#
# $Header:  /lib/sv/sh/runscript-functions               Exp $
# $Author: (c) 2015 -tclover <tokiclover@gmail.com>      Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.0 2015/04/30 21:09:26                      Exp $
#

EEND='{ end 0; return; };'
EBUSY='{ end 1 "busy"; return 16; };'

env_rs()
{
	[ -n "${*}" ] && set_env "RS_OPTIONS" "${@}"
}

rs_status()
{
	local msg
	svc_state -s && msg=started || msg=stopped
	echo -n ${msg}
}

rs_add()
{
	svc_state -e && ln -fns ${RS_SVCDIR}/${SVC_NAME} ${RS_RUNDIR}
}

svc_del()
{
	eval rm -fr "\${${SV_SRV}_RUNDIR}/${SVC_NAME}"
}
svc_zap()
{
	rm -f ${SV_TMPDIR}/${SVC_NAME}_OPTIONS ${SV_TMPDIR}/*/${SVC_NAME}
}

rs_cmd()
{
	local ARGS CMD FAIL cmd val
	FAIL='{ svc_zap; break; };' cmd="${1}"

	case "${cmd}" in
		(start|stop)
		case "${2}" in
			(stage) shift 2; svc_stage --${cmd} "${@}"; return;;
			(*) CMD="${cmd}_pre ${cmd} ${cmd}_post";;
		esac;;
		(restart) command -v ${cmd} >${NULL} 2>&1 ||
			CMD="stop_pre stop stop_post
			   start_pre start start_post";;
		(add|status) CMD=rs_${cmd} ;;
		(*) svc_cmd "${@}"; return ;;
	esac

	begin "service ${cmd}: "
	case "${cmd}" in
		(start)
		svc_wait || eval ${EBUSY}
		svc_state -s && eval ${EEND}
		svc_mark  -d
		svc_depend || return;;
		(stop)
		svc_wait || eval ${EBUSY}
		svc_state -f && eval ${EEND}
		svc_state -s || eval ${EEND}
		svc_mark  -d;;
	esac

	for cmd in ${CMD}; do
		command -v ${cmd} >${NULL} 2>&1 || continue
		eval ${cmd} ${ARGS}
		case ${?} in
			(0)
			case ${cmd} in
				(start) svc_mark -s -u;;
				(stop)  svc_mark -S -u;;
			esac;;
			(*)
			case ${cmd} in
				(*_pre)  val=2; eval ${FAIL};;
				(*_post) val=3; eval ${FAIL};;
			esac
			val=$((${val}+1));;
		esac
	done
	end ${val-${?}}
	return ${val}
}

svc_level()
{
	local ACT SRC opt svc

	case "${1}" in
		(-0) ACTION=sysinit LEVEL=S;;
		(-1) ACTION=boot    LEVEL=S;;
		(-2)
		case "$(cat /proc/cmdline)" in
			(*nonetwork*) ACTION=nonetwork LEVEL=2;;
			(*single*)    ACTION=single  LEVEL=1;;
			(*default*|*) ACTION=default LEVEL=3;;
		esac;;
		(-3) ACTION=${ACTION:=shutdown} LEVEL=${LEVEL:=0};;
		(*) return;;
	esac

	if yesno ${RC_INIT_SYS:-YES}; then
		begin "${MSG:-System ${ACTION}}\n"
		RUNLEVEL=${LEVEL} rc ${ACTION}
		end ${?}
	fi
	[ -d "${SV_RUNDIR}" ] || tmp_service

	case "${ACTION}" in
		(sysinit) return;;
		(defau*|nonet*)
	case "${ACTION}" in
		(defau*) ACT='rm -f' SRC=;;
		(nonet*) ACT='touch' SRC=;;
	esac
		for svc in ${SV_SERVICE}/net*; do
			eval ${ACT} ${svc}/down
		done;;
		(*) SRC=/.${ACTION};;
	esac

	SRC=${SV_SERVICE}${SRC}
	${SV_LIBDIR}/sh/dep -v ${1} -d ${SRC}
	case "${SV_RUNDIR}" in
		("${SV_SERVICE}") opt=-a;;
		(*) opt=-LRp;;
	esac
	for svc in ${SRC}/*; do
		cp ${opt}u ${svc} ${SV_RUNDIR}
	done
}

svc_stage()
{
	local args cmd lvl opt ret svc
	local CMD DEP SRV dep df i srv

	args="$(getopt -o 0123Sfrsv -l fork,start,stop,rs,sv -n stage -s sh -- "${@}")"
	eval set -- ${args}

	while true; do
	case "${1}" in
		(-[0123]) lvl=${1};;
		(-S|--stop) cmd=stop ;;
		(-s|--sta*) cmd=start;;
		(-r|--rs) srv=rs; SRV="${SRV} ${srv}";;
		(-v|--sv) srv=sv; SRV="${SRV} ${srv}";;
		(*) break;;
	esac
	shift
	done
:	${lvl:=-2}
:	${cmd:=start}
	svc_level ${lvl}
	export RS_STAGE=stage${lvl}
	yesno ${RS_PARALLEL:-No} && opt='&'

	case ${cmd} in
		(start) DEP="${SV_SRT_DEP_ORD}" ORD='2 1 0';;
		(stop)  DEP="${SV_SOP_DEP_ORD}" ORD='0 1 2';;
	esac
	case "${lvl}" in
		(-[03]) SRV=rs;;
	esac
	args="${DEP##* }"

	for srv in ${SRV:-sv rs}; do
	case ${srv} in
		(rs) CMD='${RS_SVCDIR}/${svc}'    ;;
		(sv) CMD='${SV_SVCDIR}/${svc}/run';;
	esac
	df=${SV_TMPDIR}/deps/${RS_STAGE}/${srv}
	[ -f ${df} ] || ${SV_LIBDIR}/sh/dep --${srv} ${lvl}
	[ -f ${df} ] && source ${df} || continue

	for dep in ${DEP}; do
		dep=${dep%:*}
		for i in ${ORD}; do
			case ${i} in
				(0)
				case "${dep}" in
					("${args%:*}") ;;
					(*) continue   ;;
				esac;;
			esac

			eval SVC=\"\$${dep}_${i}\"
			for svc in ${SVC}; do
				eval [ -x ${CMD} ] || continue
				eval ${CMD} ${cmd} &
			done
			for svc in ${SVC}; do
				eval [ -x ${CMD} ] || continue
				eval ${CMD} ${cmd} ${opt}
				ret=$((${ret}+${?}))
			done
		done
	done
	done
	return ${ret}
}

svc_wait()
{
	local FILE LIMIT NAME OPT VAL

	case "${1}" in
		(-E) OPT='!'; shift;;
	esac
	LIMIT=${1:-6000} NAME=${2:-${SVC_NAME}}
	FILE=${3:-${SV_TMPDIR}/down/${NAME}}

	while [ ${OPT} -e ${FILE} ]; do
		VAL=$((${VAL}+1)); sleep 0.01s
		case ${VAL} in
			(*00|*000) info "Waiting for ${NAME}...(${VAL%00} seconds)";;
		esac
		[ ${VAL} -eq ${LIMIT} ] && return 1
	done
	return 0
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
