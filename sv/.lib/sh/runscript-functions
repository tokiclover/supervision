#
# $Header:  /lib/sv/sh/runscript-functions               Exp $
# $Author: (c) 2015-6 tokiclover <tokiclover@gmail.com>  Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.1 2016/05/01 21:09:26                      Exp $
#

EEND='{ end 0; return; };'
EBUSY='{ end 1 "busy"; return 16; };'

env_rs()
{
	[ -n "${*}" ] && set_env "RS_OPTIONS" "${@}"
}

rs_status()
{
	local msg
	svc_state -s && msg=started || msg=stopped
	echo -n ${msg}
}

rs_add()
{
	svc_state -e && ln -fns ${RS_SVCDIR}/${SVC_NAME} ${RS_RUNDIR}
}

svc_del()
{
	eval rm -fr "\${${SV_TYPE}_RUNDIR}/${SVC_NAME}"
}
svc_zap()
{
	rm -f ${SV_TMPDIR}/${SVC_NAME}_OPTIONS ${SV_TMPDIR}/*/${SVC_NAME}
}

rs_cmd()
{
	local ARGS CMD FAIL cmd val
	FAIL='{ svc_zap; break; };' cmd="${1}"

	case "${cmd}" in
		(start|stop) CMD="${cmd}_pre ${cmd} ${cmd}_post";;
		(restart) command -v ${cmd} >${NULL} 2>&1 ||
			CMD="stop_pre stop stop_post
			   start_pre start start_post";;
		(add|status) CMD=rs_${cmd} ;;
		(*) svc_cmd "${@}"; return ;;
	esac

	begin "service ${cmd}: "
	case "${cmd}" in
		(start)
		svc_wait || eval ${EBUSY}
		svc_state -s && eval ${EEND}
		svc_mark  -d
		svc_depend || return;;
		(stop)
		svc_wait || eval ${EBUSY}
		svc_state -f && eval ${EEND}
		svc_state -s || eval ${EEND}
		svc_mark  -d;;
	esac

	for cmd in ${CMD}; do
		command -v ${cmd} >${NULL} 2>&1 || continue
		eval ${cmd} ${ARGS}
		case ${?} in
			(0)
			case ${cmd} in
				(start) svc_mark -s -u;;
				(stop)  svc_mark -S -u;;
			esac;;
			(*)
			case ${cmd} in
				(*_pre)  val=2; eval ${FAIL};;
				(*_post) val=3; eval ${FAIL};;
			esac
			val=$((${val}+1));;
		esac
	done
	end ${val-${?}}
	return ${val}
}

svc_level()
{
	local ACT SRC opt svc

	case "${1}" in
		(-0) ACTION=sysinit LEVEL=S;;
		(-1) ACTION=boot    LEVEL=S;;
		(-2)
		case "$(cat /proc/cmdline)" in
			(*nonetwork*) ACTION=nonetwork LEVEL=2;;
			(*single*)    ACTION=single  LEVEL=1;;
			(*default*|*) ACTION=default LEVEL=3;;
		esac;;
		(-3) ACTION=${ACTION:=shutdown} LEVEL=${LEVEL:=0};;
		(*) return;;
	esac

	if yesno ${RC_INIT_SYS:-YES}; then
		begin "${MSG:-System ${ACTION}}\n"
		RUNLEVEL=${LEVEL} rc ${ACTION}
		end ${?}
	fi
	[ -d "${SV_RUNDIR}" ] || tmp_service

	case "${ACTION}" in
		(sysinit) return;;
		(defau*|nonet*)
	case "${ACTION}" in
		(defau*) ACT='rm -f' SRC=;;
		(nonet*) ACT='touch' SRC=;;
	esac
		for svc in ${SV_SERVICE}/net*; do
			eval ${ACT} ${svc}/down
		done;;
		(*) SRC=/.${ACTION};;
	esac

	SRC=${SV_SERVICE}${SRC}
	${SV_LIBDIR}/sh/dep -v ${1} -d ${SRC}
	case "${SV_RUNDIR}" in
		("${SV_SERVICE}") opt=-a;;
		(*) opt=-LRp;;
	esac
	for svc in ${SRC}/*; do
		cp ${opt}u ${svc} ${SV_RUNDIR}
	done
}

svc_wait()
{
	local FILE LIMIT NAME OPT VAL

	case "${1}" in
		(-E) OPT='!'; shift;;
	esac
	LIMIT=${1:-6000} NAME=${2:-${SVC_NAME}}
	FILE=${3:-${SV_TMPDIR}/wait/${NAME}}

	while [ ${OPT} -e ${FILE} ]; do
		VAL=$((${VAL}+1)); sleep 0.01s
		case ${VAL} in
			(*00|*000) info "Waiting for ${NAME}...(${VAL%00} seconds)";;
		esac
		[ ${VAL} -eq ${LIMIT} ] && return 1
	done
	return 0
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
