#
# $Header:  /lib/sv/sh/runscript-functions               Exp $
# $Author: (c) 2015 -tclover <tokiclover@gmail.com>      Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 1.0 2015/04/24 21:09:26                      Exp $
#

env_rs()
{
	[ -n "${*}" ] && set_env "RS_OPTIONS" "${@}"
}

rs_status()
{
	local msg
	svc_state -s && msg=started || msg=stopped
	echo -n ${msg}
}

rs_add()
{
	svc_state -e && ln -fns ${RS_SVCDIR}/${SVC_NAME} ${RS_RUNDIR}
}

svc_del()
{
	eval rm -fr "\${${SV_SRV}_RUNDIR}/${SVC_NAME}"
}
svc_zap()
{
	rm -f ${SV_TMPDIR}/${SVC_NAME}_OPTIONS ${SV_TMPDIR}/*/${SVC_NAME}
}

rs_cmd()
{
	local ARGS CMD END FAIL cmd val
	END='{ end 0; return; }' cmd="${1}"
	FAIL='{ svc_zap; break; };'

	case "${cmd}" in
		(start|stop)
		case "${2}" in
			(stage) ARGS="${1} ${3}" CMD=svc_stage cmd=stage;;
			(*) CMD="${cmd}_pre ${cmd} ${cmd}_post";;
		esac;;
		(restart) command -v ${cmd} >${NULL} 2>&1 ||
			CMD="stop_pre stop stop_post
			   start_pre start start_post";;
		(add|status) CMD=rs_${cmd} ;;
		(*) svc_cmd "${@}"; return ;;
	esac

	begin "service ${cmd}: "
	case "${cmd}" in
		(start)
		rs_wait   || { end 1 "busy"; return 4; }
		svc_state -s && eval ${END}
		svc_mark  -d
		svc_depend || return;;
		(stop)
		svc_state -f || eval ${END}
		svc_state -s || eval ${END};;
	esac

	for cmd in ${CMD}; do
		command -v ${cmd} >${NULL} 2>&1 || continue
		eval ${cmd} ${ARGS}
		case ${?} in
			(0)
			case ${cmd} in
				(start) svc_mark -s -u;;
				(stop)  svc_mark -S -u;;
			esac;;
			(*)
			case ${cmd} in
				(*_pre)  val=2; eval ${FAIL};;
				(*_post) val=3; eval ${FAIL};;
			esac
			val=$((${val}+1));;
		esac
	done
	end ${val-${?}}
	return ${val}
}

rs_stage()
{
	local args cmd lvl opt ret svc
	local CMD DEP SRV dep df i line srv
	args="$(getopt -o 0123Sfrsv -l fork,start,stop,runscript,supervision \
		-n stage -s sh -- "${@}")"
	eval set -- ${args}

	while [ ${#} -ge 1 ]; do
	case "${1}" in
		(*-[0123]) lvl=${1};
		case "${1}" in
			(*-0) tmp_service;
			      ACTION=sysinit LEVEL=S;;
			(*-1) ACTION=boot    LEVEL=S;;
			(*-2) [ -e "${SV_TMPDIR}"/sv ] || svc_tmpdir;
			case "$(cat /proc/cmdline)" in
				(*nonetwoork*) ACTION=nonetwoork LEVEL=2;;
				(*single*)    ACTION=single  LEVEL=1;;
				(*default*|*) ACTION=default LEVEL=3;;
			esac;;
			(*-3) ACTION=${ACTION:=shutdown} LEVEL=${LEVEL:=0};;
		esac;;
		(-f|--fo*) opt='&'  ;;
		(-S|*stop) cmd=stop ;;
		(-s|*sta*) cmd=start;;
		(-r|--runs*) SRV=rs srv=${1};;
		(-v|--supe*) SRV=sv srv=${1};;
		(--) ;;
	esac
	shift
	done

	if yesno ${RC_SYS:-YES}; then
		begin "${MSG:-System ${ACTION}}\n"
		RUNLEVEL=${LEVEL} rc ${ACTION}
		end ${?}
	fi

	[ -n "${lvl}" ] || return 1
:	${cmd:=start}
:	${SRV:=rs}
	export RS_STAGE=stage-${lvl#*-}

	case ${cmd} in
		(start) ${SV_LIBDIR}/sh/dep ${lvl} ${srv:-r}
		        DEP='need use after before' ORD='2 1 0';;
		(stop)  DEP='before after use need' ORD='0 1 2';;
	esac
	case ${SRV} in
		(rs) CMD='${RS_SVCDIR}/${svc}'     ;;
		(sv) CMD='${SV_SERVICE}/${svc}/run';;
	esac

	for dep in ${DEP}; do
		local ${dep}_0 ${dep}_1 ${dep}_2
		df=${SV_TMPDIR}/deps/${RS_STAGE}/${SRV}_${dep}
		[ -f ${df} ] && source ${df} || continue

		for i in ${ORD}; do
			case ${i} in
				(0)
				case ${dep} in
					(${DEP##* });;
					(*) continue;;
				esac;;
			esac
			for svc in $(eval echo \$${dep}_${i}); do
				eval [ -x ${CMD} ] || continue
				eval ${CMD} ${cmd} ${opt}
				ret=$((${ret}+${?}))
			done
		done
	done
	return ${ret}
}

rs_wait()
{
	local VAL
	while [ -e ${SV_TMPDIR}/down/${1-${SVC_NAME}} ]; do
		VAL=$((${VAL}+1))
		[ ${VAL} -eq ${2-65536} ] && return 1
	done
	return 0
}

svc_stage()
{
	yesno ${RS_PARALLEL:-YES} && rs_stage "${@}" -f
	rs_stage "${@}"
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
