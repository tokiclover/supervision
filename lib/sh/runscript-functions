#
# $Id:  @(#) runscript-functions    2.0 2018/08/02 21:09:26           Exp $
# $C$:  Copyright (c) 2015-2018 tokiclover <tokiclover@gmail.com>     Exp $
# $L$:  2-clause/new/simplified BSD License                           Exp $
#

:	${SV_LIBDIR:=/lib/sv}
:	${SV_SVCDIR:=/etc/sv}
:	${SV_RUNDIR:=/run/sv}
:	${SV_CONFDIR:=${SV_SVCDIR}.conf.d}
:	${SV_CONFLOCAL:=${SV_SVCDIR}.conf.local.d}
:	${SV_TMPDIR:=${SV_RUNDIR}/.tmp}
:	${name:=${SVC_NAME}}
:	${__cmd__:=${0##*/}}
:	${__cmd_args__:="${@}"}
:	${COLOR:=Yes}
:	${LOGDIR:=/var/log}


if [ -z "${__RUNSCRIPT_FUNCTIONS__}" ]; then
__RUNSCRIPT_FUNCTIONS__=1

NETWORKFS='afs ceph cifs coda davfs fuse fuse.sshfs gfs glusterfs lustre ncpfs nfs nfs4 ocfs2 shfs smbfs'
NULL='/dev/null'

__SV_DEPS_ORDER__='need:NEED use:USE before:BEFORE after:AFTER'
__SV_PREFIX__=/usr

_PATH_STDPATH=/usr/bin:/bin:/usr/sbin:/sbin
case "${__SV_PREFIX__}" in
	(/usr|/usr/local) PATH=${_PATH_STDPATH} ;;
	(/*) PATH=${_PATH_STDPATH}:${__SV_PREFIX__}/bin:${__SV_PREFIX__}/sbin ;;
esac
PATH=${SV_LIBDIR}/bin:${SV_LIBDIR}/sbin:${PATH}:/usr/local/bin:/usr/local/sbin
readonly LOGDIR SV_CONFDIR SV_CONFLOCAL NULL
readonly __SV_DEPS_ORDER__ __SV_PREFIX__ _PATH_STDPATH


umask 022

. ${SV_SVCDIR}.conf
[ -n "${__FUNCTIONS__}"              ] || . "${SV_LIBDIR}"/sh/functions
[ -n "${__SUPERVISIONS_FUNCTIONS__}" ] || . "${SV_LIBDIR}"/sh/supervision-functions
[ -n "${__CGROUP_FUNCTIONS__}"       ] || . "${SV_LIBDIR}"/sh/cgroup-functions

checkpath()
{
	${SV_LIBDIR}/bin/checkpath "${@}"
}
fstabinfo()
{
	${SV_LIBDIR}/bin/fstabinfo "${@}"
}
mountinfo()
{
	${SV_LIBDIR}/bin/mountinfo "${@}"
}
service()
{
	${SV_LIBDIR}/sbin/service "${@}"
}
waitfile()
{
	${SV_LIBDIR}/bin/waitfile "${@}"
}

rs_status()
{
	local msg
	SVC_DEBUG "function=rs_status( ${@} )"
	svc_state -s && msg=started || msg=stopped
	echo -n ${msg}
	[ "${msg}" = "started" ]
}

svc_add()
{
	SVC_DEBUG "function=svc_add( ${@} )"
	[ -n "${SV_INITLEVEL}" ] || return
	svc_state -e && ln -fns ${__svc__} ${SV_SVCDIR}.init.d/${SV_INITLEVEL}
}
SVC_DEBUG()
{
	if yesno ${SVC_SYSLOG}; then
		logger "${name}: debug: ${@}"
	fi
	if yesno ${SVC_DEBUG}; then
		local message="${*}"
		__print_len__=$((${#message}+${#name}+9))
		printf "${__print_eol__}${name}: debug: ${@}${__eol_print__}" >&2
	fi
	return 0
}
svc_del()
{
	SVC_DEBUG "function=svc_del( ${@} )"
	[ -n "${SV_INITLEVEL}" ] || return
	rm -fr ${SV_SVCDIR}.init.d/${SV_INITLEVEL}/${SVC_NAME}
}
svc_zap()
{
	SVC_DEBUG "function=svc_zap( ${@} )"
	rm -f ${SV_TMPDIR}/*/${SVC_NAME}
}

svc_check_pid()
{
	SVC_DEBUG "function=svc_check_pid( ${@} )"

	local arg cmd pid pidfile="${SV_TMPDIR}/pids/${SVC_NAME}"
	#
	# XXX: wait the pidfile
	#
	if [ -n "${SVC_PIDFILE}" ]; then
		if ! svc_wait ${SVC_TIMEOUT_UP:-${SV_TIMEOUT_UP:-10}} ${SVC_PIDFILE}; then
			error "Failed to start daemon -- or fix \`${SVC_PIDFILE}'"
			return 1
		fi
	fi
	if [ "${SV_UNAME}" = "Linux" ]; then
		arg="${SVC_PIDFILE:+-F${SVC_PIDFILE}}"
	fi
	set -- $(pgrep ${arg} ${SVC_USER:+-u ${SVC_USER}} -f ${SVC_CMD} 2>${NULL})

	if [ ${#} = 0 ]; then
		return 1
	elif [ ${#} = 1 ] || [ "${pidfile}" != "${SVC_PIDFILE}" ]; then
		echo -n "${1}" >${pidfile}
	elif [ -n "${SVC_PIDFILE}" -a -r "${SVC_PIDFILE}" ]; then
		read pid <${SVC_PIDFILE}
		echo -n "${pid}" >${pidfile}
	else
		if [ -z "${SVC_OPTS}" ]; then
			return 0
		fi
		pgrep -l ${SVC_USER:+-u ${SVC_USER}} -f ${SVC_CMD} 2>${NULL} | \
		while read pid cmd arg; do
			if [ "x${arg}" = "x${SVC_OPTS}" ]; then
				echo "${pid}" >${pidfile}
				break
			fi
		done
	fi
:	${SVC_PIDFILE:=${pidfile}}
	ENV_SET SVC_PIDFILE
	return 0
}

rs_cmd()
{
	local ARGS='"${@}"' cmd="${1}" val
	SVC_DEBUG "function=rs_cmd( ${@} )"

	case "${cmd}" in
		(start|stop)
			if [ "${cmd}" = "start" ]; then
				svc_config || return 4
				svc_depend "${cmd}" || return 3
			fi
			cmd="${cmd}_pre ${cmd} ${cmd}_post";;
		(restart) command -v ${cmd} >${NULL} 2>&1 ||
			cmd="stop_pre stop stop_post
			   start_pre start start_post";;
		(add|status) cmd=rs_${cmd} ;;
		(*) svc_cmd "${@}"; return ;;
	esac
	shift

	#
	# this is done internaly (rs) already
	#
	if ! svc_wait; then
		error "service is busy -- or remove ${SV_TMPDIR}/wait/${SVC_NAME}?"
		return 1
	fi

	begin "service ${__cmd__}: "
	for cmd in ${cmd}; do
		command -v ${cmd} >${NULL} 2>&1 || continue
		SVC_DEBUG "function=${cmd}( ${@} )"
		eval ${cmd} ${ARGS}
		case ${?} in
			(0) ;;
			(*) val=1; break;;
		esac
	done
	end ${val:-${?}}
}

svc_sig()
{
	SVC_DEBUG "function=svc_sig( ${@} )"
	if [ -z "${1}" ]; then
		error "insufficient/invalid argument"
		return 1
	fi

	if [ -n "${SVC_PIDFILE}" -a -e "${SVC_PIDFILE}" ]; then
		pkill -${1} -F ${SVC_PIDFILE} -x ${SVC_CMD##*/}
	else
		error "no pidfile found -- SVC_PIDFILE should be defined"
		return 1
	fi
}

svc_wait()
{
	local x p t v=0 i=5 r arg pid
	local __wait_file__=${SV_TMPDIR}/wait/${SVC_NAME}
	SVC_DEBUG "function=svc_wait( ${@} )"

	for x; do
	case "${1}" in
		(-E) arg=${1} ;;
		(-p) pid=true ;;
		(*) break ;;
	esac
	shift
	done
	t="${1:-60}"
	x=${2:-${__wait_file__}}
	if ! yesno "${__SVC_WAIT__:-1}" && [ -z "${2}" ]; then
		return 0
	fi
	[ $((${t}%${i})) -eq 0 ] || i="${t}"

	if [ -n "${pid}" -a -n "${arg}" ] || [ -z "${arg}" -a "${x}" = "${__waitfile__}" ]; then
		if [ -n "${pid}" -a -n "${arg}" -a ! -e ${x} ]; then
			return 0
		fi
		read pid <${x}
		pid="${pid%:*}"
		pid="${pid#*=}"
		if [ -n "${pid}" ]; then
			#
			# XXX: race fix
			#
			if [ "${pid}" = "$$" ]; then
				return 0
			fi
			if ! kill -0 ${pid} >${NULL} 2>&1; then
				rm -f ${x}
				[ -n "${arg}" ] && return 0
			fi
		fi
	fi

	while [ ${v} -le ${t} ]; do
		v=$((${v}+${i}))
		if waitfile ${arg} ${i} ${x}; then
			if [ "${x}" = "${__wait_file__}"  -a -n "${arg}" ]; then
				if svc_state -w; then
					error "service is busy -- retry later"
					return 1
				fi
				printf "pid=$$:command=${__cmd__}" >${x}
				trap "rm -f ${x}" EXIT INT QUIT TERM
			fi
			return 0
		elif [ "${?}" != "2" ]; then
			error "unexpected \`waitfile' failure! bailing out!!!"
			return 2
		elif [ -n "${pid}" -a "${pid}" != "true" ]; then
			kill -0 ${pid} || rm -f ${x}
		fi
		info "Waiting for ${x} (${v} seconds)"
	done
	return 1
}

start()
{
	[ -n "${SVC_CMD}" ] || return 0

	#
	# Set up CGroup
	#
	if [ "${SV_UNAME}" = "Linux" ]; then
		if yesno "${SV_CGROUP}"; then
			cgroup_add_service
		fi
	fi
	#
	# Use ENV dir(s) if requested
	#
	cd ${SV_SVCDIR}
	yesno "${ENV_DIR}" && svc_environ

	eval ${ENV_CMD} ${ENV_OPTS} ${PRE_CMD} ${PRE_OPTS} ${SVC_CMD:-${SVC_NAME}} ${SVC_OPTS}
	if [ "${?}" = 0 ]; then
		svc_check_pid
	else
		return 1
	fi
}
stop()
{
	[ -n "${SVC_CMD}" ] || return 0

	if [ "${SV_UNAME}" = "Linux" ]; then
		if yesno "${SV_CGROUP}"; then
			cgroup_remove_service && return
		fi
	fi

	if [ -n "${SVC_PIDFILE}" -a -r "${SVC_PIDFILE}" ]; then
		local pid sig
		read pid <${SVC_PIDFILE}
		for sig in TERM QUIT KILL; do
			kill -${sig} ${pid} >${NULL} 2>&1 || continue
			waitfile -E ${SVC_TIMEOUT_DOWN:-${SV_TIMEOUT_DOWN:-30}} /proc/${pid} && \
				break
		done
	fi
	rm -f ${SVC_PIDFILE} ${SV_TMPDIR}/star/${SVC_NAME} ${SV_TMPDIR}/opts/${SVC_NAME}
}

fi #__RUNSCRIPT_FUNCTIONS__

#
# Set debug options
#
yesno "${SVC_TRACE}" && set -x

#
# Use OpenRC config file if requested
#
if yesno "${RC_OPTS}"; then
:	${RC_CONFDIR:=/etc/conf.d}
:	${RC_INITDIR:=/etc/init.d}
	DOT ${RC_CONFDIR}/${SVC_NAME}
fi


if [ -n "${__svc__}" ]; then
#
# Set up runscript environment
#
if   [ "${SV_TYPE}" = "rs" ]; then
	if [ "${name}" != "${SVC_NAME}" ]; then
	DOT "${SV_CONFDIR}/${name}"
	DOT "${SV_CONFLOCAL}/${name}"
	else
	DOT "${SV_CONFDIR}/${SVC_NAME}"
	DOT "${SV_CONFLOCAL}/${SVC_NAME}"
	fi
	DOT -e ${__svc__} || return 1
#
# Set up supervision environment
#
elif [ "${SV_TYPE}" = "sv" ]; then
:	${SVC_DIR:=${__svc__}}

	if [ "${__cmd__}" = "run" -o "${__cmd__}" = "finish" ]; then
:	${COLUMNS:=80}
	else
:	${COLUMNS:=$(tput cols)}
	trap ': COLUMNS=$(tput cols)' WINCH
	fi # __cmd__

	if [ "${name}" = "${SVC_NAME}" ]; then
	DOT "${SV_CONFLOCAL}/${SVC_NAME}"
	else
	DOT "${SV_CONFLOCAL}/${name}"
	fi
	DOT -e ${__svc__}/OPTIONS || return 1
	#
	# Handle specific (virtual) service backend/instance
	#
	if [ "${name}" = "${SVC_NAME}" ]; then
	DOT "${SVC_DIR}/OPTIONS.${SVC_NAME}"
	else
	DOT "${SVC_DIR}/OPTIONS.${name}"
	fi
	readonly SVC_PIDFILE="${SV_TMPDIR}/pids/${SVC_NAME}"
	if [ -z "${__SV_CONFIG__}" ]; then
	DOT -d ${SV_LIBDIR}/sh/SV-CONFIG
	readonly __SV_NAM__ __SVCENV__ __SV_CMD__ __SVCCMD__ __CHKCMD__ __STACMD__ \
			__LOGCMD__ __PRECMD__ __SCANCMD__ __SIGSTRT__ __SIGSTOP__ __SIGSONCE__ \
			__SIGPAUSE__ __SIGCONT__ __SIGHUP__ __SIGALRM__ __SIGINT__ __SIGTERM__ \
			__SIGKILL__ __SIGEXIT__ __SIGQUIT__ __SIGUSR1__ __SIGUSR2__ __SIGWTUP__ \
			__SIGWDWN__ __SIGRELD__
	__SV_CONFIG__=1
	fi
fi # SV_TYPE=sv

if [ -n "${__cmd__}" ]; then
DOT ${SV_TMPDIR}/opts/${SVC_NAME}
fi # __cmd__

SV_SERVICE=${__svc__}
RC_SERVICE=${__svc__}
export SV_SERVICE RC_SERVICE
readonly SV_SERVICE RC_SERVICE

fi # __svc__

if [ -z "${__env__}" ]; then
DOT ${SV_TMPDIR}/env
__env__=1
fi # __env__
if [ -z "${__environ__}" ]; then
DOT ${SV_TMPDIR}/environ && __environ__=1 || __environ__=0
fi # __environ__

#
# Set debug options
#
if yesno "${SVC_TRACE}"; then
	set -x
fi
if yesno "${SVC_DEBUG:-${SV_DEBUG}}"; then
	SVC_DEBUG=true
else
	SVC_DEBUG=false
fi
if yesno "${SVC_SYSLOG:-${SV_SYSLOG}}"; then
	SVC_SYSLOG=true
else
	SVC_SYSLOG=false
fi
if yesno "${SVC_SYSLOG_INFO:-${SV_SYSLOG_INFO}}"; then
	SVC_SYSLOG_INFO=true
else
	SVC_SYSLOG_INFO=false
fi

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
